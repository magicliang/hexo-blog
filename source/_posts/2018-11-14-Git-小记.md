---
title: Git 小记
date: 2018-11-14 15:20:11
tags:
- git
---
## areas

![](https://ws1.sinaimg.cn/large/66dd581fly1fx7ifbcqpoj20m80c90sy.jpg)

staging area 也叫 index。

HEAD 指向的 commit，是当前分支的顶端。哪怕这个 commit 后面还有很多其他 commit，看起来 branch 在最后一个 commit 上，实际上 branch 的顶端，还是在 head 上的。

## 修改提交


用git log可以查看提交历史，以便确定要回退到哪个版本。

要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。这个命令的本质，是找到没有 branch 的 head 指向的悬垂节点。

1. 大部分情况下，我们可以使用`git reset --hard commit_id` 的方式来调整当前整个 git 仓库内的内容，这个操作会把代码仓库里的多余内容抹掉。**`git reset --hard`大部分时间没什么用，因为 head 本来已经是 head 了，但它会把 working directory 里的内容给丢掉。**

2. 如果我们想把代码回滚到特定的版本，但保留 commit 之间的修改，则可以使用`git -c core.quotepath=false -c log.showSignature=false reset --soft 6ef50b9f2186fbb0f89b100dfe7399c2b918446d` 命令，这样特定版本之间的修改，会停留在 staged 区域，等待再次被修改为一个 commit 并提交。**同样是保留文件修改，soft 会帮你写好 commit**。

3. ：`git -c core.quotepath=false -c log.showSignature=false reset --mixed 6ef50b9f2186fbb0f89b100dfe7399c2b918446d`，则 commit 之间的代码会被放到 working directory（而不是 staging area），等待 add 和 commit。**同样是保留文件修改，mixed 不会帮你写好 commit。而且，它是 reset 的默认选项**。
4. ` git -c core.quotepath=false -c log.showSignature=false reset --keep 6ef50b9f2186fbb0f89b100dfe7399c2b918446d` 看不出这个命令和`hard`有什么区别。

## 签出操作

git checkout最简单的用法，显示工作区，暂存区和HEAD的差异。

注意 checkout 本身不是 reset，纯粹的 checkout 会导致 head 指针比 branch 的最后头指针更加 behind。head 会因此进入 detached HEAD STATE。因为 checkout 本来是拿来移动 branch 的。

我们在 detached head 上乱修改，也可以产生提交。但这个提交是不能当做任何一个 branch 的内容的，也就是在一个匿名的 branch 内。但我们可以再做一次 checkout -b，新建出真正的分支。似乎可以这么理解，git checkout 历史版本，是为了**在历史版本上创建新分支而不是更正当前版本**而存在的。

因为 checkout 总是被用来切换分支，所以它会导致 local modification 被覆盖，所以我们在 checkout 的时候，总是要先 commit 或者 stash 一下我们的修改。

## 提交回退

我们可以用以下的命令，产生某一个 commit 涉及到的文件的反操作，而不是 commit 和 head 之间的反操作。

`git -c core.quotepath=false -c log.showSignature=false revert 6ef50b9f2186fbb0f89b100dfe7399c2b918446d --no-commit`

这样可以提交反操作，而不丢失正操作的 commit。这样做的好处是，commit 历史是 append only 的，不会被修改。

## merge

merge 的用途是把一个分支的内容合入另一个分支。

要把 master 的代码合并入 feature。

```
# 方法一
git checkout feature
git merge master

# 方法二
git merge master feature
```

git merge 当然会产生一个多余的 commit，而且如果有冲突的话，还必须在这个 commit 里修改，化解冲突。我们在工程上倒是可以规定所有的 merge 都必须是 no conflict 的，这就要求我们合并里的 source 分支，反而要先 merge target 分支，这样所有的 merge 都是 fast-forward 的。

## rebase

rebase 的用途也是把一个分支的内容合入另一个分支。

作为 merge 的替代选择，它会产生一个非常整洁的提交记录：

```
git checkout feature
git rebase master
```

rebase 的本质，顾名思义，**是改变当前分支的 branch out 的位置**。即，把当前 feature 整个移动到 master 的 head 之后，即所谓的 rebase onto。

![](https://ws1.sinaimg.cn/large/66dd581fly1fx7kv8ud9hj20rs0li74b.jpg)

rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。如果你想把 rebase 之后的 master 分支推送到远程仓库，Git 会阻止你这么做，因为两个分支包含冲突。但你可以传入 --force 标记来强行推送。就像下面一样：

```
# 小心使用这个命令！
git push --force
```

它会重写远程的 master 分支来匹配你仓库中 rebase 之后的 master 分支，对于团队中其他成员来说这看上去很诡异。所以，务必小心这个命令，只有当你知道你在做什么的时候再使用。

![](https://ws1.sinaimg.cn/large/66dd581fly1fx7m5u2y5jj20rs0lx3yn.jpg)

rebase 因为会修改 branch 的历史，所以 never use it on public branches。因为这会给其他人的开发分支带来分歧。

而如果我们使用交互式的 rebase，就是把`git rebase -i master`。则会把我们要 branch out 的 commit 做一个整理。

![](https://ws1.sinaimg.cn/large/66dd581fly1fx7m7vai0fj20ic0e076w.jpg)

## remote

```
# 列出所有远程仓库
git remote -v

# 增加一个 ssh 协议/git 协议的 git repo，命名为 pb（通常还是命名为 origin）。
git remote add pb git://github.com/paulboone/ticgit.git

# 从远程仓库获取信息
git fetch pb

# 推送修改到 origin 里，可以修改这个参数推送到不同的 origin 里
git push origin master

# 显示远程仓库
git remote show origin

# 重命名
git remote rename pb paul

# 删除
git remote rm paul
```

## commit

```
# 多行注释
git commit -m "
多行注释
"

# 修改最近一次提交的 comment
# 如果要修改多个 commit 的注释，要先 rebase 到一个 commit，在交互过程中修改
git commit --amend
```