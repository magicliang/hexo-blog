---
title: Spring 的基础配置
date: 2020-03-29 19:22:07
tags:
- Java
- Spring
---
# Spring 原生的功能

## 带有 name 的注解

```java
@Repository("movieDao")

@Bean("writer2")

@Transactional(value="txManager1")
```

## @Configuration

@Configuration 注解本质上还是 @Component，但又不同于 @Component，详见[《Spring @Configuration 和 @Component 区别
》][1]。@Configuration 里的 @Bean 方法可以嵌套使用，而@Component 里的 @Bean 方法不可以。
它天然可以被加载，还可以触发其他 bean 的加载。
它只能被放置在类型上。

```java

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component

@Configuration
 public class AppConfig {

     @Bean
     public MyBean myBean() {
         // instantiate, configure and return bean ...
     }
 }

// Bootstrapping @Configuration classes
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
 ctx.register(AppConfig.class);
 ctx.refresh();
 MyBean myBean = ctx.getBean(MyBean.class);
 // use myBean ...

// 除了它可以被  <context:component-scan/> 扫到，还可以自己配置 ComponentScan
@Configuration
@ComponentScan("com.acme.app.services")
 public class AppConfig {
     // various @Bean definitions ...
 }
 
 @Configuration
 // 可以定义多个源
 @PropertySource("classpath:/com/acme/app.properties")
 @PropertySource("classpath:bar.properties")
 // 甚至这样
@PropertySources({
    @PropertySource("classpath:foo.properties"),
    @PropertySource("classpath:bar.properties")
})
 public class AppConfig {

// 带有缺省值的 value，不要用对象初始值了
@Value( "${jdbc.url:aDefaultUrl}" )
private String jdbcUrl;

     @Value("${bean.name}") String beanName;

     @Bean
     public MyBean myBean() {
         return new MyBean(beanName);
     }
 }
 
@Configuration
// 等同于 <import/>，需要用 AnnotationConfigApplicationContext 来 bootstrap。
@Import(DatabaseConfig.class)
public class AppConfig {

     private final DatabaseConfig dataConfig;

     public AppConfig(DatabaseConfig dataConfig) {
         this.dataConfig = dataConfig;
     }

     @Bean
     public MyBean myBean() {
         // reference the dataSource() bean method
         return new MyBean(dataConfig.dataSource());
     }
 }
 

@Configuration
// 等同于 <import/>，需要用 AnnotationConfigApplicationContext 来 bootstrap。
@ImportResource(locations={"classpath:applicationContext.xml"})
public class XmlConfiguration {

}

@Profile("development")
 @Configuration
 public class EmbeddedDatabaseConfig {

     @Bean
     public DataSource dataSource() {
         // instantiate, configure and return embedded DataSource
     }
 }

 @Profile("production")
 @Configuration
 public class ProductionDatabaseConfig {

     @Bean
     public DataSource dataSource() {
         // instantiate, configure and return production DataSource
     }
 }
 
@Configuration
 public class ProfileDatabaseConfig {

     @Bean("dataSource")
     @Profile("development")
     public DataSource embeddedDatabase() { ... }

     @Bean("dataSource")
     @Profile("production")
     public DataSource productionDatabase() { ... }
 }

 @Configuration
 public class AppConfig {

     @Inject DataSource dataSource;

     @Bean
     public MyBean myBean() {
         return new MyBean(dataSource);
     }

     @Configuration
     static class DatabaseConfig {
         @Bean
         DataSource dataSource() {
             return new EmbeddedDatabaseBuilder().build();
         }
     }
 }

// When we put @Lazy annotation over the @Configuration class, it indicates that all the methods with @Bean annotation should be loaded lazily.
// 这个注解当然也可以和 Component 一起用。相对应的是 eager initialization。
@Lazy
@Configuration
@ComponentScan(basePackages = "com.baeldung.lazy")
public class AppConfig {
 
    @Bean
    public Region getRegion(){
        return new Region();
    }
 
    @Bean
    public Country getCountry(){
        return new Country();
    }
}
```

##  @EnableAsync

参考[《How To Do @Async in Spring》][2]：

```java
// By default, Spring will be searching for an associated thread pool definition: either a unique TaskExecutor bean in the context, or an Executor bean named "taskExecutor" otherwise. If neither of the two is resolvable, a SimpleAsyncTaskExecutor will be used to process async method invocations.
 @Configuration
 @EnableAsync
 public class AppConfig implements AsyncConfigurer {
 
    @Override
     public Executor getAsyncExecutor() {
         ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
         executor.setCorePoolSize(7);
         executor.setMaxPoolSize(42);
         executor.setQueueCapacity(11);
         executor.setThreadNamePrefix("MyExecutor-");
         executor.initialize();
         return executor;
     }

     @Override
     public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
         return new MyAsyncUncaughtExceptionHandler();
     }
     
  @Bean
     public MyAsyncBean asyncBean() {
         return new MyAsyncBean();
     }
     
 }
 
 public class MyAsyncBean {
 // First – let's go over the rules – @Async has two limitations:
// it must be applied to public methods only
// self-invocation – calling the async method from within the same class – won't work
// The reasons are simple – the method needs to be public so that it can be proxied. And self-invocation doesn't work because it bypasses the proxy and calls the underlying method directly.
// 这个注解会让 Spring 生成一个 aspect 方面
 @Async("threadPoolTaskExecutor")
// 无参数异步方法
public void asyncMethodWithConfiguredExecutor() {
    System.out.println("Execute method with configured executor - "
      + Thread.currentThread().getName());
    }

// 有返回值的方法。Future.get() 会抛出 ExecutionException。从这个异常里可以取出原有的异常-不管是受检异常还是非受检异常。
@Async
public Future<String> asyncMethodWithReturnType() {
    System.out.println("Execute method asynchronously - "
      + Thread.currentThread().getName());
    try {
        Thread.sleep(5000);
        return new AsyncResult<String>("hello world !!!!");
    } catch (InterruptedException e) {
        //
    }
 
    return null;
}
 }
 
// 自定义异常处理器，这要求在 AsyncConfigurer 里专门使用工厂方法生成相应的 bean。
public class CustomAsyncExceptionHandler
  implements AsyncUncaughtExceptionHandler {
 
    @Override
    public void handleUncaughtException(
      Throwable throwable, Method method, Object... obj) {
  
        System.out.println("Exception message - " + throwable.getMessage());
        System.out.println("Method name - " + method.getName());
        for (Object param : obj) {
            System.out.println("Parameter value - " + param);
        }
    }
}
```

对应的 xml
```xml
 <beans>

     <task:annotation-driven executor="myExecutor" exception-handler="exceptionHandler"/>

     <task:executor id="myExecutor" pool-size="7-42" queue-capacity="11"/>

     <bean id="asyncBean" class="com.foo.MyAsyncBean"/>

     <bean id="exceptionHandler" class="com.foo.MyAsyncUncaughtExceptionHandler"/>

 </beans>
```

## @EnableScheduling


```java
 @Configuration
 @EnableScheduling
 public class AppConfig {
    // 1.cron是设置定时执行的表达式，如 0 0/5 * * * ?每隔五分钟执行一次
    // 2.zone表示执行时间的时区
    // 3.fixedDelay 和fixedDelayString 表示一个固定延迟时间执行，上个任务完成后，延迟多长时间执行
    // 4.fixedRate 和fixedRateString表示一个固定频率执行，上个任务开始后，多长时间后开始执行
     // 5.initialDelay 和initialDelayString表示一个初始延迟时间，第一次被调用前延迟的时间
     // 每 1000 毫秒运行一次
     @Scheduled(fixedRate=1000)
     public void work() {
         // task execution logic
     }
 }
 
 
 public class MyTask {

     @Scheduled(fixedRate=1000)
     public void work() {
         // task execution logic
     }
 }
 
@Configuration
 @EnableScheduling
 public class AppConfig implements SchedulingConfigurer {

     @Override
     public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
         taskRegistrar.setScheduler(taskExecutor());
     }

     @Bean(destroyMethod="shutdown")
     public Executor taskExecutor() {
         return Executors.newScheduledThreadPool(100);
     }
 }
 
 // 自定义任务执行
 @Override
     public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
         taskRegistrar.setScheduler(taskScheduler());
         taskRegistrar.addTriggerTask(
             new Runnable() {
                 public void run() {
                     myTask().work();
                 }
             },
             new CustomTrigger()
         );
     }

     @Bean(destroyMethod="shutdown")
     public Executor taskScheduler() {
         return Executors.newScheduledThreadPool(42);
     }

     @Bean
     public MyTask myTask() {
         return new MyTask();
     }
```

对应的 xml
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:task="http://www.springframework.org/schema/task"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.2.xsd
        http://www.springframework.org/schema/task
        http://www.springframework.org/schema/task/spring-task-3.2.xsd">
    <task:annotation-driven executor="jobExecutor" scheduler="jobScheduler" />
   <task:executor id="jobExecutor" pool-size="5"/>
   <task:scheduler id="jobScheduler" pool-size="10" />
</beans>
```

## @EnableTransactionManagement

TransactionInterceptor 是被 proxy 或者 advice 加入到调用栈中：

```java
@Configuration
// In both of the scenarios above, @EnableTransactionManagement and <tx:annotation-driven/> are responsible for registering the necessary Spring components that power annotation-driven transaction management, such as the TransactionInterceptor and the proxy- or AspectJ-based advice that weave the interceptor into the call stack when JdbcFooRepository's @Transactional methods are invoked.
 @EnableTransactionManagement
 public class AppConfig {

     @Bean
     public FooRepository fooRepository() {
         // configure and return a class having @Transactional methods
         return new JdbcFooRepository(dataSource());
     }

     @Bean
     public DataSource dataSource() {
         // configure and return the necessary JDBC DataSource
     }

     @Bean
     public PlatformTransactionManager txManager() {
         return new DataSourceTransactionManager(dataSource());
     }
 }
```

```xml
<beans>
     <tx:annotation-driven/>
     <bean id="fooRepository" class="com.foo.JdbcFooRepository">
         <constructor-arg ref="dataSource"/>
     </bean>
     <bean id="dataSource" class="com.vendor.VendorDataSource"/>
     <bean id="transactionManager" class="org.sfwk...DataSourceTransactionManager">
         <constructor-arg ref="dataSource"/>
     </bean>
 </beans>
```

Please note that proxy mode allows for interception of calls through the proxy only; local calls within the same class cannot get intercepted that way.

Note that if the mode() is set to AdviceMode.ASPECTJ, then the value of the proxyTargetClass() attribute will be ignored. Note also that in this case the spring-aspects module JAR must be present on the classpath, with compile-time weaving or load-time weaving applying the aspect to the affected classes. There is no proxy involved in such a scenario; local calls will be intercepted as well.

aspectj 的织入可以增强本地调用，默认的 proxy mode 不可以。

AdviceMode.PROXY
AdviceMode.ASPECTJ

各种 mode 的解释见[《Optimal @EnableTransactionManagement Configuration》][3]，必须配合`proxyTargetClass`配置使用：

> This configuration says how the transaction aspect will be applied.
> Briefly:
> 
> adviceMode=proxy, proxyTargetClass=true Cglib is used as proxy
> mechanism. If you use this, cglib must be on classpath, your proxied
> classes must have nonparametric constructor and they can't be final
> (cglib creates a child class as the proxy).
> 
> adviceMode=proxy, proxyTargetClass=false Jdk proxy mechanism is used.
> You only can proxy classes that implements a interface for methods
> that should be transactional. Jdk proxy can be type casted to the
> interfaces but can't be type casted as the original proxied class.
> 
> So, for adviceMode=proxy, the decision relies more on how are your
> code standards and what constraints result from used proxy mechanism.
> 
> adviceMode=aspectJ uses aspectJ library, which does byte code
> intrumentation instead of proxying.
> 
> adviceMode=aspectJ, compile-time weaving You should incorporate
> aspectJ instrumentation during a build process in your build scripts.
> 
> adviceMode=aspectJ, load-time weaving Instrumentation is performed on
> runtime. You have to put the aspectj agent as jvm parameter.
> 
> Using aspectJ is more powerful and probably more performant. It is
> also less invasive in terms of restrictions put on the classes you
> want to be transactional. However, proxy mode is simple Spring's out
> of the box solution.

基本上静态织入的 AspectJ 的性能最好（我们大多数时候都习惯使用 compile-time-weaving，但其实 AspectJ 还支持 load-time-weaving），但平时我们用得最多的还是 cglib 生成的 proxy（因为 Spring 会自动帮我们决策最优的方案）。

## @EnableAspectJAutoProxy

```java
@Configuration
// 这个注解本身和 aspectj 没什么关系，倒是没有它 @Aspect 注解不能生效
 @EnableAspectJAutoProxy
 public class AppConfig {

     @Bean
     public FooService fooService() {
         return new FooService();
     }

     @Bean
     public MyAspect myAspect() {
         return new MyAspect();
     }
 }


@Aspect
public class MyAspect {
     @Before("execution(* FooService+.*(..))")
     public void advice() {
         // advise FooService methods as appropriate
     }
 }
```

web application context 和 DispatcherServlet application contexts 是两个 context，需要单独声明 @EnableAspectJAutoProxy at multiple levels。

## @EnableWebMvc

```java
 @Configuration
 @EnableWebMvc
 @ComponentScan(
        basePackageClasses = { MyConfiguration.class },
        excludeFilters = { @Filter(type = FilterType.ANNOTATION, value = Configuration.class) }
 )
 public class MyConfiguration extends WebMvcConfigurerAdapter {

        @Override
        public void addFormatters(FormatterRegistry formatterRegistry) {
                formatterRegistry.addConverter(new MyConverter());
        }

        @Override
        public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
                converters.add(new MyHttpMessageConverter());
        }

        // @Override methods ...

 }
```

## ContextConfiguration

`spring-test`特有,`ContextConfiguration` 要和`@Configuration`或者`@Component`配合使用。

```java
 @RunWith(SpringRunner.class)
 @TestPropertySource("/foo.properties")
 @ContextConfiguration(classes = {AppConfig.class, DatabaseConfig.class})
 @TestPropertySource(properties = {"foo=bar"})
 // SpringBoot 特有
 @SpringBootTest(properties = {"foo=bar"}, classes = SpringBootPropertiesTestApplication.class)
 public class MyTests {

     @Autowired MyBean myBean;

     @Autowired DataSource dataSource;

     @Test
     public void test() {
         // assertions against myBean ...
     }
 }
```
## @PropertySource

property 跨上下文继承的关系见[《Properties with Spring and Spring Boot》][4]。
[《官方的列表》][5]。

```java
@Configuration
 @PropertySource("classpath:/com/acme/app.properties")
 public class AppConfig {

     @Inject Environment env;

     @Bean
     public MyBean myBean() {
         return new MyBean(env.getProperty("bean.name"));
     }
 }
```

## @ComponentScan

它指定的扫描属性依赖于 basePackageClasses()/basePackages() (or its alias value()。

## 环境 API

环境 API 意味着对 properties 和 profile 的建模，`Environment`接口扩展了`PropertyResolver`接口。

参考[《Spring的Property配置加载和使用过程及Environment的初始化过程
》][6]：
> 首先，PropertySource其实就是包装的具体配置，跟Properties差不多。
> 
> 而PropertyResolver，就是用于对PropertySource进行特殊处理，比如解析holder、转换值的类型等。
> 
> Spring启动时，默认会new一个StandardEnvironment，这个类里面就默认添加了两个PropertySource（SystemProperties和SystemEnvironment，分别对应System.getenv和System.getProperty）
> 
> 注意，可能是为了使用方便，Environment实现了PropertyResolver接口。

每一个参数，但凡可以用-D 动态传入，也应该可以使用环境变量，甚至 JNDI 的配置，其相对顺序参考[《Spring Boot Configuration Priority order》][7]：

1. command-line arguments.
2. The Java system parameters obtained through System.getproperties ().
3. Operating system environment variables.
4. The JNDI attribute obtained from java:comp/env.
5. The "random.*" property generated by Randomvaluepropertysource.
6. Apply the properties file outside of the Jar file . (via
7. spring.config.location parameter)
8. Apply the properties file inside the Jar file.
9. A property file that is declared through the "@PropertySource"
10. annotation in the application Configuration Java class (the Java
11. class that contains the "@Configuration" annotations).
12. The default property declared by the "Springapplication.setdefaultproperties".
 
###  在 java 中获取环境变量：环境变量System.getenv() 或者 environment.getenv()

System.getenv() 方法是获取指定的环境变量的值。它有两种方法，一种是接收参数为任意字符串，当存在指定环境变量时即返回环境变量的值，否则返回null。另外一种是不接受参数，那么返回的是所有的环境变量。

```java
// 接收参数为任意字符串
public static String getenv(String name) {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new RuntimePermission("getenv."+name));
        }

        return ProcessEnvironment.getenv(name);
    }

// 不接受参数
public static java.util.Map<String,String> getenv() {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new RuntimePermission("getenv.*"));
        }

        return ProcessEnvironment.getenv();
    }
```

### 在 java 中获取属性：System.getProperty() 或者 environment.getProperty()

获取系统的相关属性，包括文件编码、操作系统名称、区域、用户名等，此属性一般由jvm自动获取，不能设置。这个必须接受一个String类型的参数，返回值的类型也是String，如果想获取所有的系统的相关属性值可以使用System.getProperties（）

> java.version    Java 运行时环境版本               
> java.vendor Java 运行时环境供应商             
> java.vendor.url Java 供应商的 URL                
> java.home   Java 安装目录                    
> java.vm.specification.version   Java 虚拟机规范版本               
> java.vm.specification.vendor    Java 虚拟机规范供应商             
> java.vm.specification.name  Java 虚拟机规范名称               
> java.vm.version Java 虚拟机实现版本               
> java.vm.vendor  Java 虚拟机实现供应商             
> java.vm.name    Java 虚拟机实现名称               
> java.specification.version  Java 运行时环境规范版本            
> java.specification.vendor   Java 运行时环境规范供应商          
> java.specification.name Java 运行时环境规范名称            
> java.class.version  Java 类格式版本号                 
> java.class.path Java 类路径                      
> java.library.path   加载库时搜索的路径列表             
> java.io.tmpdir  默认的临时文件路径                 
> java.compiler   要使用的 JIT 编译器的名称          
> java.ext.dirs   一个或多个扩展目录的路径           
> os.name 操作系统的名称                    
> os.arch 操作系统的架构                    
> os.version  操作系统的版本                    
> file.separator  文件分隔符（在 UNIX 系统中是“/” ）
> path.separator  路径分隔符（在 UNIX 系统中是“:” ）
> line.separator  行分隔符（在 UNIX 系统中是“/n” ）
> user.name   用户的账户名称                    
> user.home   用户的主目录                      
> user.dir    用户的当前工作目录

对应的命令行用法是`java -jar jarName -DpropertyName=value`，如`java -Djavadoop.database.password=admin4321 -jar app.jar`。

参考[《System.getenv()和System.getProperty() 的区别》][8]。

### profile 的定义

> a named, logical group of bean definitions to be registered with the
> container only if the given profile is active

和 Configuration 类似，用来聚合 bean。**与之相对应地，maven 中的 profile 就是用来聚合配置用的**。一旦被注册进了某个 profile，则 bean 不会轻易地被默认激活。

```java
@Component
@Profile("dev")
public class DevDatasourceConfig

@Component
@Profile("!dev")
public class DevDatasourceConfig

// 程序式地激活 profile 的方法
@Configuration
public class MyWebApplicationInitializer 
  implements WebApplicationInitializer {
 
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
  
        servletContext.setInitParameter(
          "spring.profiles.active", "dev");
    }
}

@Autowired
private ConfigurableEnvironment env;
...
env.setActiveProfiles("someProfile");

<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/app-config.xml</param-value>
</context-param>
<context-param>
    <param-name>spring.profiles.active</param-name>
    <param-value>dev</param-value>
</context-param>

-Dspring.profiles.active=dev
export spring_profiles_active=dev
```

### properties 的例子

> properties files, JVM system properties, system environment variables,
> JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and
> so on.

所有的 properties 都由`PropertySourcesPlaceholderConfigurer`对`${}`进行注入。

```java
 @Configuration
 public class AppConfig {

     @Autowired Environment env;

     @Bean
     public MyBean myBean() {
         MyBean myBean = new MyBean();
         myBean.setName(env.getProperty("bean.name"));
         return myBean;
     }
 }
```

## Aware 接口

 - ApplicationContextAware
 - ApplicationEventPublisherAware
 - BeanClassLoaderAware
 - BeanFactoryAware
 - BeanNameAware
 - BootstrapContextAware
 - EmbeddedValueResolverAware
 - EnvironmentAware
 - ImportAware
 - LoadTimeWeaverAware
 - MessageSourceAware
 - NotificationPublisherAware
 - ResourceLoaderAware
 - SchedulerContextAware
 - ServletConfigAware
 - ServletContextAware

## PropertySourcesPlaceholderConfigurer

其中PropertyPlaceholderConfigurer是Spring3.1之前使用的。
PropertySourcesPlaceholderConfigurer是Spring3.1之后使用的。

有了这个机制，才能让特定的 .properties 注入到特定的 xml 占位符里面。

```xml

<!-- bean 形式 -->
<bean id="propertyConfigurer"class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
   <property name="location">
     <value>conf/sqlmap/jdbc.properties</value>
   </property>
    <property name="fileEncoding">
      <value>UTF-8</value>
    </property>
</bean>

<bean id="propertyConfigurer"class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">  
    <property name="locations">
        <list>
            <value>/WEB-INF/mail.properties</value>  
            <value>classpath: conf/sqlmap/jdbc.properties</value>//注意这两种value值的写法
     </list>
    </property>
</bean>

<!-- spring容器中最多只能定义一个context:property-placeholder!(spring和springmvc不是同一容器，PropertyPlaceholderConfigurer可以同时存在于spring和springmvc中 -->
<!-- context attribute 形式，这种形式更优于 bean 的形式 -->
<context:property-placeholder location="classpath*:/WEB-INF/mail.properties" />
```

PropertySourcesPlaceholderConfigurer本质上是一个BeanFactoryPostProcessor。解析XML的流程在BeanFactoryPostProcessor之前， 优先将配置文件的路径以及名字通过Setter传入PropertySourcesPlaceholderConfigurer。

如上BeanFactoryPostProcessor的优先级又优于其余的Bean。因此可以实现在bean初始化之前的注入。

参考：

 1. [《Spring PropertySourcesPlaceholderConfigurer工作原理》][9]
 2. [《Spring 常用的两种PropertyPlaceholderConfigurer》][10] 基本还是 MergedProperties 那一套。
 3. [《Spring Properties Loader》][11]

## xml 配置

`annotation-config`等字符串实际上指的是一个 element 的 attribute。

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"  profile="dev">

     <context:component-scan base-package="com.xh.spring.aop">
        <context:include-filter type="annotation" 
                 expression="org.aspectj.lang.annotation.Aspect"/>
    </context:component-scan>
    <context:annotation-config/>
    
    <context:property-placeholder ignore-unresolvable="true" location="classpath*:/base.properties,classpath:database.properties" />

    <mvc:annotation-driven/>
    <!-- proxy-target-class属性值决定是基于接口的还是基于类的代理被创建。如果proxy-target-class 属性值被设置为true，那么基于类的代理将起作用（这时需要cglib库）。如果proxy-target-class属值被设置为false或者这个属性被省略，那么标准的JDK 基于接口的代理。高版本spring自动根据运行类有没有实现特定接口选择JDK或CGLIB代理，我们无需设置proxy-target-class属性，JDK动态代理是模拟接口实现的方式，cglib是模拟子类继承的方式，一般采用前者，因为前者效率高。后者不建议使用。-->
  <aop:config proxy-target-class="true">
        <aop:aspect id="log" ref="logHandler">
            <aop:pointcut id="printLog" expression="execution(* cn.sw.study.common.test.spring.aop.service..*(..))" />
            <aop:before method="LogBefore" pointcut-ref="printLog" />
            <aop:after method="LogAfter" pointcut-ref="printLog" />
        </aop:aspect>
    </aop:config>
    <bean class="com.acme.AppConfig"/>
    
    <!-- PropertiesFactoryBean 也可以支持 @Value：@Value("#{propBean['filePath']}")或者@Value("#{propBean.filePath}") -->
    <bean id="propBean" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
  <property name="locations" value="classpath:jdbc.properties"/>  
</bean>
    
    <!-- 事务管理 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
    <bean id="transactionManager"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource">
            <ref bean="routingDatasource"/>
        </property>
    </bean>
    
    <!-- 引用其它配置文件 -->
    <import resource="a.xml"/>
    <import resource="b.xml"/>
    <import resource="springmvc-web.xml"/>
</beans>

<context:component-scan/> 
<context:property-placeholder/>
<!-- @Value("${filePath}") -->
<context:property-placeholder location="classpath*:/WEB-INF/mail.properties" />
```

# Spring Boot 特性

Spring Boot 在扫描类路径的时候扫到特定的包的时候，会自动激活事务管理、Spring MVC 等功能。

## TransactionAutoConfiguration

spring-boot 不需要打开 @EnableTransactionManagement。

```java

// 一个隐藏起来的 @Configuration 也可以激活事务管理
@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)
@Configuration
@EnableTransactionManagement
protected static class TransactionManagementConfiguration {
}


@Configuration
@ConditionalOnClass(PlatformTransactionManager.class)
@AutoConfigureAfter({ JtaAutoConfiguration.class, HibernateJpaAutoConfiguration.class,
        DataSourceTransactionManagerAutoConfiguration.class, Neo4jDataAutoConfiguration.class })
@EnableConfigurationProperties(TransactionProperties.class)
public class TransactionAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public TransactionManagerCustomizers platformTransactionManagerCustomizers(
            ObjectProvider<PlatformTransactionManagerCustomizer<?>> customizers) {
        return new TransactionManagerCustomizers(customizers.orderedStream().collect(Collectors.toList()));
    }

    @Configuration
    @ConditionalOnSingleCandidate(PlatformTransactionManager.class)
    public static class TransactionTemplateConfiguration {

        private final PlatformTransactionManager transactionManager;

        public TransactionTemplateConfiguration(PlatformTransactionManager transactionManager) {
            this.transactionManager = transactionManager;
        }

        @Bean
        @ConditionalOnMissingBean(TransactionOperations.class)
        public TransactionTemplate transactionTemplate() {
            return new TransactionTemplate(this.transactionManager);
        }

    }

    @Configuration
    @ConditionalOnBean(PlatformTransactionManager.class)
    @ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)
    public static class EnableTransactionManagementConfiguration {

        @Configuration
        @EnableTransactionManagement(proxyTargetClass = false)
        @ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "false",
                matchIfMissing = false)
        public static class JdkDynamicAutoProxyConfiguration {

        }

        @Configuration
        @EnableTransactionManagement(proxyTargetClass = true)
        @ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "true",
                matchIfMissing = true)
        public static class CglibAutoProxyConfiguration {

        }

    }
}
```

## @ConditionalOnClass

## @ConditionalOnSingleCandidate

## @ConditionalOnMissingBean

## @ConditionalOnBean

在早期版本有 bug，参考[《深入Spring Boot：那些注入不了的Spring占位符（${}表达式）》][12]。

## @ConfigurationProperties

```java
@Configuration
@ConfigurationProperties(prefix = "javadoop.database")
public class DataBase {
String url;
String username;
String password;
// getters and setters
}
```

## 惰性加载

> By default, ApplicationContext implementations eagerly create and
> configure all singleton beans as part of the initialization process.
> Generally, this pre-instantiation is desirable, because errors in the
> configuration or surrounding environment are discovered immediately,
> as opposed to hours or even days later. When this behavior is not
> desirable, you can prevent pre-instantiation of a singleton bean by
> marking the bean definition as lazy-initialized. A lazy-initialized
> bean tells the IoC container to create a bean instance when it is
> first requested, rather than at startup.

```yaml
spring:
  main:
    lazy-initialization: true
```

### 随机值

```yaml
# 由 RandomValuePropertySource 提供
random.number=${random.int}
random.long=${random.long}
random.uuid=${random.uuid}
```

  [1]: https://blog.csdn.net/isea533/article/details/78072133
  [2]: https://www.baeldung.com/spring-async
  [3]: https://stackoverflow.com/questions/22569438/optimal-enabletransactionmanagement-configuration
  [4]: https://www.baeldung.com/properties-with-spring
  [5]: https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config
  [6]: http://blog.zollty.com/b/archive/spring-property-configuration-loading-and-use-process-and-the-initialization-process-of-environment.html
  [7]: https://topic.alibabacloud.com/a/spring-boot-configuration-priority-order_8_8_30371727.html
  [8]: https://www.cnblogs.com/javJoker/p/7262840.html
  [9]: https://blog.csdn.net/qyp199312/article/details/54313784
  [10]: https://www.jianshu.com/p/a3c7ff0de5ac
  [11]: https://www.jianshu.com/p/ba84993d2f06
  [12]: http://hengyunabc.github.io/spring-placeholder-inject-failed-cases/
