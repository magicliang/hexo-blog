---
title: OOM 调查使用到的工具
date: 2018-09-10 11:33:04
tags:
- JVM
- 操作系统
---
# 基础工具
1 top 与 htop。这两个东西比 free 好用。比较神奇的是，为什么线上还有装了 htop这样的非标准 top。

2 pmap。这个东西是莫枢自己也用来 dump 详细的内存轮廓的地址，但可能需要使用他提到的一个 Serviceability Agent API 来读才读得懂。这个工具的输出可以看到各段内存的起止，但不经帮助，很难读出各个子线程的栈来。
这个命令在非 root/sudo 权限下看到的是 jvm 启动参数，在 root/sudo 权限下看到的是内存轮廓，这时候就需要 Serviceability Agent API 了。

3 smem。这个东西对内存的 RSS/PSS/USS 分析得很好。但并不能帮助我们直接获知我们最期待的栈内存轮廓，比如当前 JVM 的 stack 到底是怎么分布的，占了多少内存？而且更重要是，线上机器没有这个工具。

4 直接 cat /proc/pid/smaps 其实其他的进程内存查看工具的信息可能都能在这里看得到，但是需要耐心。而且，这个东西在线上也是看不了的，看来也是需要 root。

5 ps_mem.py 这是一个对 private ram usage 分析得不错的脚本。但是需要 root。

6 jstack。 这是目前 thread dump 最详尽的命令行工具了。但线上用不了。

7 其他 jmx 客户端。 JConsole/JVisualVM/JMC。全部都连不上线上。

8 飞行记录器。这个东西甲骨文收费非常贵，但好处是可以录下来再在本地回放。目前看来，所有的 JVM 运行时状态分析，只有这个是最完备的了。它还有一个命令行工具 jcmd，可以动态地使用飞行记录器的功能和各种 jmx client 特有的动能。

9 其他，这里有本[书][1]，讲了很多 system tuning 的原理和工具，但对 JVM 的调试好像没有什么特别的好处。

10 看 jstat -gc PID 也可以看到内存轮廓。其中 MU 是永久代信息。同理，JMX 客户端也可以看到这个值。

11 directbuffer 和 metaspace 的回收严重依赖 fullgc，ygc 是远远不够的。

12 查看元空间的尺寸： `usr/local/java8/bin/java  -XX:+PrintFlagsFinal -version | grep Metaspace`
   查看所有的 native memory：`jcmd 16200  VM.native_memory scale=MB`，这需要使用 java 8 自带的 nmt 功能：https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html

注意，jmc 可以直接看到 direct buffer，比 native memory tracker 优秀，但看不到 thread 内存。

nmt 正好反过来，能看到线程消耗的内存，看不到 direct buffer。

13 基础原理汇总： 

[聊聊jvm的-XX:MaxDirectMemorySize][2]
[https://dzone.com/articles/permgen-and-metaspace][3]
[Native Memory Tracking in JVM][4]
[JVM源码分析之堆外内存完全解读][5]
[JVM Anatomy Quark #12: Native Memory Tracking][6]
[聊聊HotSpot VM的Native Memory Tracking][7]
[NMT 工具输出表][8]
[Java程序在Linux上运行虚拟内存耗用很大][9]
[native-mem-tracking.md][10]

```bash
jcmd 140466 VM.native_memory baseline

jcmd 140466 VM.native_memory detail.diff

jcmd 140466 VM.native_memory summary

jcmd 230163 VM.native_memory summary
```

14 线程栈的原理：https://www.zhihu.com/question/64685291

15 thread 源码：http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/tip/src/share/vm/runtime/thread.cpp

16 rocketmq 的 jvm 配置： https://github.com/apache/rocketmq/blob/cdb494c4dcef45c506d79bfdbe727e319cdce681/distribution/bin/runserver.cmd

# 矛盾的 disableexplicitgc

https://blog.csdn.net/aitangyong/article/details/39403031
https://stackoverflow.com/questions/32912702/impact-of-setting-xxdisableexplicitgc-when-nio-direct-buffers-are-used
https://coldwalker.com/2018/12/troubleshooter_directbytebuffer_memory_issue/

# top 排序
press shift+m after running the top command
or you can interactively choose which column to sort on
press Shift+f to enter the interactive menu
press the up or down arrow until the %MEM choice is highlighted
press s to select %MEM choice
press enter to save your selection
press q to exit the interactive menu
Or specify the sort order on the command line


  [1]: https://juejin.im/post/5c9ced366fb9a070e344c614
  [2]: https://juejin.im/post/5c9ced366fb9a070e344c614
  [3]: https://dzone.com/articles/permgen-and-metaspace
  [4]: https://www.baeldung.com/native-memory-tracking-in-jvm
  [5]: http://lovestblog.cn/blog/2015/05/12/direct-buffer/
  [6]: https://shipilev.net/jvm/anatomy-quarks/12-native-memory-tracking/
  [7]: https://cloud.tencent.com/developer/article/1406522
  [8]: https://docs.oracle.com/en/java/javase/12/troubleshoot/diagnostic-tools.html#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37
  [9]: https://blog.csdn.net/u010686469/article/details/77319599
  [10]: https://gist.github.com/prasanthj/48e7063cac88eb396bc9961fb3149b58