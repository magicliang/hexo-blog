---
title: MySQL 基本功
date: 2020-02-19 21:03:17
tags:
- MySQL
---
# 插件式架构

[MySQL 的插件式架构.xmind](MySQL 的插件式架构.xmind)
![MySQL 的插件式架构.png](MySQL 的插件式架构.png)

# 索引问题

索引的出现是为了减少单一维度查询时，搜索数据的成本。

## 索引的基础架构

不同的存储引擎支持不同的索引数据结构。
Innodb 支持的索引数据结构只有 B+树。

### B+树

![b+tree-index-image.png](b+tree-index-image.png)

B+树的每个节点可以被认为是一个磁盘块（block）-可以认为 MySQL 的磁盘块等同于 OS 的数据页，大小通常为 4k/8k/16k。磁盘块通常是双层的，第一层表示存储的数据项（data entry），第二层表示指向子节点的指针（pointer）。但 B+树本身只有叶子节点真实数据，非叶子节点存储的数据**指引了指针的搜索方向（作为分界符）**。

三层的 B+树能够存储的上百万条数据。也就是说，第三层是叶子节点，且叶子节点的数量为百万级。

假设数据总量为 M：

因为分界的关系，所以如果一个磁盘块能够拥有的数据项数量为 n，则可以拥有的指针数量为 n + 1。

则树的高度 height = log(n+1为底)M。

而数据的块大小又是固定的，也就意味着数据项的大小，决定了 n 的大小。所以 int 为 4 字节，bigint 为 4 字节，产生的 key_length 不一样，最终导致的树的形态也就不一样-注意，这就是B+树的数据只放在叶子节点的原因，非叶子节点存有最大限度的小数据（只有索引数据），它的 n 值最大，树的高度越低。反之，如果一个非叶子节点只能存储一个数据，则树退化为线性表。

总结：小数据 + 非叶子节点只存放小索引的设计 = B+树的高度。转换成 B 树则树的高度会变高很多，增加了磁盘 I/O。

### 最左匹配原则

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

但高版本的 MySQL 开始支持跳跃索引。

## explain 思维导图

![MySQl Explain.png](MySQl Explain.png)
[MySQl Explain.xmind](MySQl Explain.xmind)

## 一级索引与二级索引

假设查询总是触发索引：

 - 辅助索引如果没有触发 Using Index （即触发覆盖索引，和 Using Index Condition 不一样）要回表。
 - 使用 id 不需要回表。

# 索引选择

多个索引同时存在，也每次只能使用一个索引。有重叠的索引，如 status、status + time 可能导致任一索引不被使用，有时候单一索引反而更简单。因为添加索引的字段一定要有很好的区分度【cardinality】，区分度不够的时候回表的开销不如 all（full table scan）。

数据量小(比如小于2000 时)的时候 type 可能会是 all，即不走索引直接全表扫描，原理是类似 pg 和 oracle 的 cost-based optimizer。

using index condition 不是 using index，还是可能回表。

# 与 order by 的关系

1、如果你只需要结果集中的某几行，那么建议使用limit。这样这样的话可以避免抓取全部结果集，然后再丢弃那些你不要的行。

2、对于order by查询，带或者不带limit可能返回行的顺序是不一样的。

3、如果limit row_count 与 order by 一起使用，那么在找到第一个row_count就停止排序，直接返回。

4、如果order by列有相同的值，那么MySQL可以自由地以任何顺序返回这些行。换言之，只要order by列的值不重复，就可以保证返回的顺序。

5、可以在order by子句中包含附加列(组合 order by)，以使顺序具有确定性。

6、ORDER BY的索引优化。如果一个SQL语句形如：
SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort];
在[sort]这个栏位上建立索引就可以实现利用索引进行order by 优化。相反地，如果 order by 没有命中索引，就会导致 file sort，mysql 5.7 也不例外。但很多时候，没有命中索引，也不一定就会慢，命中索引或多或少都会导致回表，有可能不回表的速度更快-这取决于 query optimizer 怎么看待这个查询计划。考虑多方诉求的话，可以打破常规，考虑把 id 加进索引里。

7、WHERE + ORDER BY的索引优化，形如：
SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort];
建立一个联合索引(columnX,sort)来实现order by 优化。

注意：如果columnX对应多个值，如下面语句就无法利用索引来实现order by的优化
SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY[sort];

8、WHERE+ 多个字段ORDER BY
SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;
建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。

MySQL Order By不能使用索引来优化排序的情况
* 对不同的索引键做 ORDER BY ：(key1,key2分别建立索引)
SELECT * FROM t1 ORDER BY key1, key2;

* 在非连续的索引键部分上做 ORDER BY：(key_part1,key_part2建立联合索引;key2建立索引)
SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2;

* 同时使用了 ASC 和 DESC：(key_part1,key_part2建立联合索引)
SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;

* 用于搜索记录的索引键和做 ORDER BY 的不是同一个：(key1,key2分别建立索引)
SELECT * FROM t1 WHERE key2=constant ORDER BY key1;

* 如果在WHERE和ORDER BY的栏位上应用表达式(函数)时，则无法利用索引来实现order by的优化
SELECT * FROM t1 ORDER BY YEAR(logindate) LIMIT 0,10;

特别提示:
1>mysql一次查询只能使用一个索引。如果要对多个字段使用索引，建立复合索引。
2>在ORDER BY操作中，MySQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。

9、[如果不指定 ORDER BY，不能指望 mysql 默认返回任何默认顺序][1]。但一旦指定了 order by，[MySQL 的 order by 的默认值是 asc][2]。

10、 MySQL 8.0 开始支持[索引在磁盘上排序][3] 。

11、Databases can read indexes in both directions. 但，如果走索引的列和 order by 的列正好相反，那么查询会非常非常慢。举例，假设 t 的数据量非常大，`select * from t where gmt_create < '2019-08-11 22:00:00' order by id`，如果 MySQL 的查询优化器决定使用 id作为索引（MySQL 上每次只有一个索引会生效），那么查询会先从主索引的树的左边往右扫（**扫描顺序由 order by 的顺序决定**），如果当前时间和 2019-08-11 22:00:00 之间的数据量非常大，会导致非常大的 filtered，查询会异常地慢（这种情况有点类似 index jumping-注意看这个[例子][4]的 6.3）。

12、order-by 语句可能会误导查询优化器，选择错误的索引，形成错误的查询计划。这是一个无数的 RD 和 DBA 工作中会遇到的[已知 bug][5]。

  [1]: https://dba.stackexchange.com/questions/6051/what-is-the-default-order-of-records-for-a-select-statement-in-mysql#comment498655_6053
  [2]: https://dev.mysql.com/doc/refman/8.0/en/sorting-rows.html
  [3]: https://www.percona.com/blog/2016/10/20/mysql-8-0-descending-indexes-can-speedup-your-queries/
  [4]: https://use-the-index-luke.com/sql/sorting-grouping/order-by-asc-desc-nulls-last
  [5]: http://mysql.taobao.org/monthly/2016/12/08/
