---
title: 线程安全与锁优化
date: 2017-11-10 19:51:43
tags:
- JVM
- 多线程
---

## 什么是线程安全 ##
&emsp;&emsp;“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。”

&emsp;&emsp;相对的线程安全，可以分成五个等级：

## 线程安全的分类 ##

### 不可变 ###
    
&emsp;&emsp;不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。

### 绝对线程安全 ###

&emsp;&emsp;Vector不是线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。

### 相对线程安全 ###

&emsp;&emsp;需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。

### 线程兼容 ###

&emsp;&emsp;可以通过特殊手段做到线程安全的普通类，绝大部分类都属于相对线程安全的。

### 线程对立 ###

&emsp;&emsp;线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System.setIn()，System.setOut()和System.runFinalizerOnExit()。

## 线程安全的实现 ##

### 互斥同步（Mutual Exclusion & Synchronization) ###

&emsp;&emsp;这是最常见（也是我们在考虑并发问题的时候，首先应该考虑的万能解决方案，也是《Java并发编程实践》和《Thinking in Java 》中最推荐的做法。）的保障并发正确性的手段。同步是指在多个线程并发访问共享数据的时候，保证共享数据在同一个时刻只被一条（使用信号量的话，多条）线程访问。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量都是实现互斥的常见方式。互斥是因，同步是果，互斥是方法，同步是目的。这些同步的手段，同样也会出现在 OS 层面上。同步的终极目标，应该是化并发的乱序，转化为类型无并发时的有序。
    
&emsp;&emsp;在 Java 里面，最基本的互斥手段就是 synchronized 关键字。它经过编译后，会转化为 moniterenter 和 moniterexit 这两个字节码指令（bytecode instructions）。这两个字节码都需要一个 reference 类型的参数来指明加锁和解锁的对象。我们当然都知道，这个reference，不是一个平凡对象实例，就是一个 Class 对象了。

&emsp;&emsp;根据虚拟机规范，在执行 monitorenter 指令时，首先尝试获取对象的锁（实际上就是去用线程信息写 markword）。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，那么把锁的计数器加1。相应地，在执行 monitorexit 时，会对计数器减1，当计数器为0时，锁就被释放了。从某种意义上来讲，这种设计可以在分布式场景下用 Redis 实现。如果获取锁失败了，那么就会进入阻塞状态，直到对象锁被释放为止。虚拟机规范对 monitorenter 和 monitorexit 两条指令的行为描述中，有两点是需要特别注意的。**首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死（阻塞）的情况。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入**对于映射到操作系统原生进程的实现，不管是阻塞还是唤醒线程，都需要操作系统的调用帮忙，也就会牵涉到用户态转变入核心态的问题（系统控制权从用户空间转入内核空间）。**这种切换需要消耗很多 CPU 时间。这也是为什么它是昂贵的原因，时间是最昂贵的。对于很多简单的getter()、setter（）操作，花在状态切换上的时间，甚至会多过用户代码执行的时间。甚至可以认为，这样的状态切换需要使用很多的汇编指令代码，以至于要使用很多的 cpu 时钟周期**。因此synchronized本身是一种重量级（Heavyweight）操作。JVM（注意，不是Java语言） 本身可能会对重量锁进行优化，使用自旋来避免频繁地切入核心态之中（自旋难道就不浪费CPU 时间了吗？）。

&emsp;&emsp;J.U.C包里专门提供了Reentrantlock来实现同步。它同样具有 syncrhonized具有的可重入、阻塞其他求锁者的特性。但它还具有三个额外的特点：

1. 等待可中断。Lock接口有实现类可以实现试锁，超时试锁等功能。这样synchronized中，其他求索线程傻等的情况可以避免。
2. 公平锁。公平锁指的是按照求锁顺序来分配锁（求锁也是有顺序的）。默认的锁（synchronized 和 ReentrantLock 的默认构造函数）是非公平的，随机给予锁，这样性能更好。
3. 绑定多个条件。在 synchronized 的时代，多个 condition 就意味着多层 synchronized。

&emsp;&emsp;synchronized 的性能屡屡被 JVM 的实现者改进，因此还是优先要使用synchronized（《TIJ》、《Java 并发实践》和《深入理解 Java 虚拟机》到此达到了同一结论）。

### 非阻塞同步（Non-Blocking Synchronization) ###

&emsp;&emsp;也就是我们常说的乐观策略。不需要加锁，也就不需要负担线程状态切换的代价。但代价是，如果真的发生了冲突，乐观操作需要付出的代价就是补偿（compensation）。最常见的补偿，应该就是不断重试（又要引入自旋了）。乐观锁的核心基石，实际上是 CAS（CompareAndSet或者 CompareAndSwap），这两个操作必须是原子化操作，这就要求现代的处理器提供这样的指令原语（instruction primitive）。JVM 虚拟机里，专门通过  Unsafe 包来向上层提供这种原语的语义。

&emsp;&emsp;CAS操作有一个很讨厌的 ABA 问题。虽然 ABA 问题本身在大部分情况下不会引起问题，但J.U.C还是提供了一个 AtomicStampedReference操作来避免这个问题（所以说，**带版本的原子值才是最安全的**）。在大多数情况下，进入互斥同步，还比用这些鸡肋功能要高效（为什么？）。

### 无同步方案 ###


#### 可重入代码（Reentrant Code） ####

&emsp;&emsp;也叫纯代码（Pure Code）。在它执行的任意时刻中断它，转而去执行另一端代码，再切换上下文回来以后，不会发生任何错误。所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的。可重入性是基本的特性。

&emsp;&emsp;其实这就是函数式编程里的纯函数，**所有的状态都由输入参数决定，结果可预测**，不依赖其他global状态。这也是为什么函数式编程在高并发下是安全的，他们天然满足栈封闭的标准。

#### 线程本地存储 ####

&emsp;&emsp;Thread中含有 ThreadLocalMap，而ThreadLocal的变量反而是ThreadLocalMap的key，ThreadLocal对应的真值**，被ThreadLocalMap强引用，而被ThreadLocal这个key弱引用。所以单单让 ThreadLocal 被回收，反而会因为无法再摸到真值而造成内存泄露。**因此，我们需要至少做几件事：
1.尽可能手动地remove threadlocal 的value。
2. 尽可能关掉线程（在使用线程池的方案里，这恐怕很难做到）。