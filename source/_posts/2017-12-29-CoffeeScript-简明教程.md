---
title: CoffeeScript 简明教程
date: 2017-12-29 19:50:37
tags:
- CoffeeScript
---

# 写在前面的话 #

&emsp;&emsp;之前在工作群里看到一个排行榜:

![](https://ws1.sinaimg.cn/large/66dd581fly1fmf6zwaftnj20iw0iqmz7.jpg)

&emsp;&emsp;在羡慕美国同行的薪水超高的同时，也奇怪为何 CoffeeScript 的生命力超过了自己之前的想象。

&emsp;&emsp;JavaScript 本是 Brendan Eich 在10天内做完的急就章之作，在设计之初，即带有大量的大意设计和缺陷。可以说，即使到了 1.5 时代，JavaScript 作为一门现代语言，依然要提防 Douglas Crockford 在《JavaScript:The Good Parts》中提出的种种陷阱。历年来，各路框架作者和超集语言作者，都不断在 JavaScript 上做出各种各样炫目的模式用法和衍生方言，足见其可提高空间之大。包括 CoffeeScript/TypeScript/Dart/Elm 等解决方案的出现，其实就是在倡导使用 Pre-JavaScript 的语言编写抽象逻辑，然后编译成原生 JavaScript 运行。

&emsp;&emsp;CoffeeScript 即是 JavaScript 1.5 时代的 Pre-JavaScript 语言中的佼佼者。其设计的语法和句法利用了 Ruby 和 Python 的优点，然而又能去除 JavaScript 中容易产生二义性的部分，可以认为是一种变换写法的 JavaScript 语言子集，也就是美化过的“The Good Parts”。CoffeeScript 的定位，本来是一门 little language，它的目的不是取代 JavaScript，而是用更好的风格来编写 JavaScript，因此其最终目标也是编译成 JavaScript。因此，很多人都把它当做下一代 JavaScript 标准出现以前的过渡用法。

&emsp;&emsp;2015年以来，ES6.0以及后来的 ES2015等标准的制定以及现代浏览器对原生语法支持的逐步实现，使得大部分众望所归的语言特性都可以在原生 JavaScript 中找到。旧的 CoffeeScript 编译的结果已然不兼容新的ES2015的发展方向，CoffeeScript 作为一个过渡时期的产物，似乎已然完成了它的历史使命。

&emsp;&emsp;但 CoffeeScript 的发展并没有停止。CofffeeScript 紧随现代 JavaScript 推出了 CoffeeScript2。这一版本的 CoffeeScript 不仅保留了大部分上一版本 Ruby/Python 风格的优美语法，也大量兼容了 ES2015 的新特性（除了 import/export 这个在前后端实行起来经常需要转义和 polyfill 的特性以外），成为了一门更加现代的 little langugage。

&emsp;&emsp;可能有读者会问，既然已经有了 ES2015，为什么还要再来一门编程语言呢？笔者认为，不同的编程语言，其实是不同的思考和设计工具。虽说图灵完备的语言总是等价的，但通过另一个角度来对问题和解建模，可以更有效地提高自己对原本掌握的语言的理解。因此，了解 CoffeeScript 的设计和使用理念，一定能对使用原生 JavaScript 编程有所脾益。

&emsp;&emsp;本文基本上是 coffeescript.org 在2.0版本后文档的摘译和简化。每一个小的知识点会配上若干的代码块，两个相连的代码块总是代表一段 CoffeeScript 代码和它编译生成的 JavaScript 代码。阅读本文需要一定的 JavaScript 基础。
    
# 简明教程 #

## CoffeeScript 是什么？ ##

**CoffeeScript 是一门编译成 Javascript 的小语言。**在 Java 风格的笨拙锈色之下，JavaScript 有着一颗华丽的心。CoffeeScript 试图用简明的方式，把 JavaScript 中的精粹部分表现出来。

CoffeeScript 的黄金法则是：“它只是 JavaScript”。代码会被一对一地编译成对等的 JS，不会有运行时解释。可以在 CoffeeScript 中无缝地使用任何现存的 JavaScript 库（反之亦然）。编译输出是可读，美化打印过的，而且趋向于和等价的手写 JavaScript 跑得一样快。

## 安装和试用 coffee ##

最新版本：2.1.0

```bash
# 为一个项目局部安装:
npm install --save-dev coffeescript

# 全局安装以在任意处执行.coffee 文件:
npm install --global coffeescript
```

假设我们有一个 test.coffee 的文件如下：

```coffee
# Assignment:
number   = 42
opposite = true

# Conditions:
number = -42 if opposite

# Functions:
square = (x) -> x * x

# Arrays:
list = [1, 2, 3, 4, 5]

# Objects:
math =
  root:   Math.sqrt
  square: square
  cube:   (x) -> x * square x

# Splats:
race = (winner, runners...) ->
  print winner, runners

# Existence:
alert "I knew it!" if elvis?

# Array comprehensions:
cubes = (math.cube num for num in list)
```

运行`coffee -c test.coffee`就会得到一个test.js 文件如下：

```javascript
// Generated by CoffeeScript 2.1.0
(function() {
  // Assignment:
  var cubes, list, math, num, number, opposite, race, square;

  number = 42;

  opposite = true;

  if (opposite) {
    // Conditions:
    number = -42;
  }

  // Functions:
  square = function(x) {
    return x * x;
  };

  // Arrays:
  list = [1, 2, 3, 4, 5];

  // Objects:
  math = {
    root: Math.sqrt,
    square: square,
    cube: function(x) {
      return x * square(x);
    }
  };

  // Splats:
  race = function(winner, ...runners) {
    return print(winner, runners);
  };

  if (typeof elvis !== "undefined" && elvis !== null) {
    // Existence:
    alert("I knew it!");
  }

  // Array comprehensions:
  cubes = (function() {
    var i, len, results;
    results = [];
    for (i = 0, len = list.length; i < len; i++) {
      num = list[i];
      results.push(math.cube(num));
    }
    return results;
  })();

}).call(this);
```

缺省的 coffee 编译结果为了最大限度地保证不污染顶层的变量，总是会把文件编译成一个立即执行的函数，使得所有变量的声明和使用局限在一个小作用域里面。当然，它也有个 bare 模式可以去掉这种立即执行函数，如果使用`import`和`export` 的功能，也可以自动进入 bare 模式。这个模式的细节很繁琐，请读者自行查阅文档。

## 普通函数 ##

```coffee
square = (x) -> x * x
cube   = (x) -> square(x) * x

# 带有默认值的函数参数
fill = (container, liquid = "coffee") ->
  "Filling the #{container} with #{liquid}..."
  
# 空函数
a = ->
```
```javascript
var cube, square;

square = function(x) {
  return x * x;
};

cube = function(x) {
  return square(x) * x;
};

var fill;

// 带有默认值的函数参数
fill = function(container, liquid = "coffee") {
  return `Filling the ${container} with ${liquid}...`;
};

  // 空函数
  var a;

  a = function() {};
```

使用`->`生成 function 函数。带默认值的参数，同样是 ES2015 的内容。

## 字符串 ##

```coffee
author = "Wittgenstein"
quote  = "A picture is a fact. -- #{ author }"

sentence = "#{ 22 / 7 } is a decent approximation of π"
```
```javascript
var author, quote, sentence;

author = "Wittgenstein";

quote = `A picture is a fact. -- ${author}`;

sentence = `${22 / 7} is a decent approximation of π`;
```

CoffeeScript 的字符串同 JavaScript 一样，可以用`"`和`'`分界。用"引用的字符串，可以用`#{}` 来进行内插（甚至可以在对象的key 里执行内插）。用'引用的字符串是字面量。

双引号的多行字符串可以自动被编译器连接起来，当然，所有的缩进都失效了：

```coffee
mobyDick = "Call me Ishmael. Some years ago --
  never mind how long precisely -- having little
  or no money in my purse, and nothing particular
  to interest me on shore, I thought I would sail
  about a little and see the watery part of the
  world..."
```
```javascript
var mobyDick;

mobyDick = "Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...";
```

使用三引号`"""`和三个单引号`'''`，还可以生成保留格式（特别是缩进）的**块**字符串：

```coffee
html = """
       <strong>
         cup of coffeescript
       </strong>
       """
       
html = '''
       <strong>
         cup of coffeescript
       </strong>
       '''
```
```javascript
var html;

html = "<strong>\n  cup of coffeescript\n</strong>";

var html;

html = '<strong>\n  cup of coffeescript\n</strong>';
```

用双引号制造出来的块字符串，也一样支持字符串内插功能。

## 对象和数组 ##

CoffeeScript 支持 JavaScript 格式的对象和数组字面量，也支持更简明的无逗号的、依靠换行的字面量：

```coffee
song = ["do", "re", "mi", "fa", "so"]

singers = {Jagger: "Rock", Elvis: "Roll"}

# 用换行来代替分隔符
bitlist = [
  1, 0, 1
  0, 0, 1
  1, 1, 0
]

# 类 YAML 格式，用换行来代替分隔符
kids =
  brother:
    name: "Max"
    age:  11
  sister:
    name: "Ida"
    age:  9
```
```javascript
var bitlist, kids, singers, song;

song = ["do", "re", "mi", "fa", "so"];

singers = {
  Jagger: "Rock",
  Elvis: "Roll"
};

bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];

kids = {
  brother: {
    name: "Max",
    age: 11
  },
  sister: {
    name: "Ida",
    age: 9
  }
};
```

CoffeeScript 也支持 ES2015的字面量语法：

```coffee
name = "Michelangelo"
mask = "orange"
weapon = "nunchuks"
turtle = {name, mask, weapon}
```
```javascript
var mask, name, output, turtle, weapon;

name = "Michelangelo";

mask = "orange";

weapon = "nunchuks";

turtle = {name, mask, weapon};
```

## 注释 ##

聪明的读者可能已经发现了注释应该怎么写，但这里还是要总结下。CoffeeScript 里的注释其实是脚本语言的注释的应用：

```coffee
###
Fortune Cookie Reader v1.0
Released under the MIT License
###

sayFortune = (fortune) ->
  console.log fortune # in bed!
```
```javascript
/*
Fortune Cookie Reader v1.0
Released under the MIT License
*/
var sayFortune;

sayFortune = function(fortune) {
  return console.log(fortune); // in bed!
};

```

值得注意的是，`###`支持了类型注解。

## 词法作用域和变量安全 ##

聪明的读者可能也发现了，在 CoffeeScript 中，是不需要手写`var`这样的关键字的。实际上，ES2015为了解决过去的 JavaScript 中不存在块级作用域这样的问题，专门提出的`const`和`let`解决方案，CoffeeScript 也不支持。在有多层变量的时候，CoffeeScript **会自动地推导变量的作用域**，保证内层的变量绝不会污染任何外层变量。每个变量的实际作用域，会被限制在它首次被声明的地方。JavaScript 无意之中忘加`var`关键字而污染全局变量的情况便不复存在了。

```coffee
outer = 1
changeNumbers = ->
  inner = -1
  outer = 10
inner = changeNumbers()
```
```javascript
var changeNumbers, inner, outer;

outer = 1;

changeNumbers = function() {
  var inner;
  inner = -1;
  return outer = 10;
};

inner = changeNumbers();
```

`outer` 因为在外部作用域里已经声明过了，所以不需要重复声明。而`inner`只是在内部作用域里被使用，所以还额外声明了一个函数内的 `inner`来专门隔离它的作用域。外部专门声明的`var inner`其实就是一个编译器为了谨慎做的声明顶部上推，在这个编译的例子里不影响任何语义。

因为无法使用`var`关键字，所以实际上我们是无法遮蔽（shadow）住外部变量的，只能在内部作用域引用外部变量。

## If,Else,Unless, 与条件赋值 ##

if/else 里可以不用写小括号和大括号，使用 python 式的缩进定界，用户也可以使用单行 if 和 unless。

```coffee
mood = greatlyImproved if singing

if happy and knowsIt
  # 用缩进来确定这一段代码是在条件块里的
  clapsHands()
  chaChaCha()
else
  showIt()

date = if friday then sue else jill
```

```javascript
var date, mood;

if (singing) {
  mood = greatlyImproved;
}

if (happy && knowsIt) {
  clapsHands();
  chaChaCha();
} else {
  showIt();
}

date = friday ? sue : jill;
```

## 不定参数语法 ##

Java 程序员里面可能都习惯了类似 ... 语法的不定参数语法来了。在 CoffeeScript 中它被称为 Splats 参数。ES2015吸收了这一语法，做出了 rest 参数。

```coffee
gold = silver = rest = "unknown"

awardMedals = (first, second, others...) ->
  gold   = first
  silver = second
  rest   = others

contenders = [
  "Michael Phelps"
  "Liu Xiang"
  "Yao Ming"
  "Allyson Felix"
  "Shawn Johnson"
  "Roman Sebrle"
  "Guo Jingjing"
  "Tyson Gay"
  "Asafa Powell"
  "Usain Bolt"
]

awardMedals contenders...

alert """
Gold: #{gold}
Silver: #{silver}
The Field: #{rest.join ', '}
"""

# 特殊的数组省略语法
popular  = ['pepperoni', 'sausage', 'cheese']
unwanted = ['anchovies', 'olives']

all = [popular..., unwanted..., 'mushrooms']

# 对象属性语法

user =
  name: 'Werner Heisenberg'
  occupation: 'theoretical physicist'

currentUser = { user..., status: 'Uncertain' }
```
```javascript
var awardMedals, contenders, gold, rest, silver;

gold = silver = rest = "unknown";

awardMedals = function(first, second, ...others) {
  gold = first;
  silver = second;
  return rest = others;
};

contenders = ["Michael Phelps", "Liu Xiang", "Yao Ming", "Allyson Felix", "Shawn Johnson", "Roman Sebrle", "Guo Jingjing", "Tyson Gay", "Asafa Powell", "Usain Bolt"];

awardMedals(...contenders);

alert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);

# 特殊的数组省略语法
var all, popular, unwanted;

popular = ['pepperoni', 'sausage', 'cheese'];

unwanted = ['anchovies', 'olives'];

all = [...popular, ...unwanted, 'mushrooms'];

// 特殊的对象属性语法
var currentUser, user,
  _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

user = {
  name: 'Werner Heisenberg',
  occupation: 'theoretical physicist'
};

currentUser = _extends({}, user, {
  status: 'Uncertain'
});
```
## 循环和表处理 ##

CoffeeScript 的 for 循环可以处理数组、对象和 range，有点类似 Python。而且，它的 for 循环是有返回值的。

```coffee
# Eat lunch.
eat = (food) -> "#{food} eaten."
eat food for food in ['toast', 'cheese', 'wine']

# Fine five course dining.
courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']
menu = (i, dish) -> "Menu Item #{i}: #{dish}" 
menu i + 1, dish for dish, i in courses

# Health conscious meal.
foods = ['broccoli', 'spinach', 'chocolate']
eat food for food in foods when food isnt 'chocolate'

# 一个使用返回值的例子
countdown = (num for num in [10..1])

# 遍历对象的例子
yearsOld = max: 10, ida: 9, tim: 11

ages = for child, age of yearsOld
  "#{child} is #{age}"

```
```javascript
// Eat lunch.
var courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;

eat = function(food) {
  return `${food} eaten.`;
};

ref = ['toast', 'cheese', 'wine'];
for (j = 0, len = ref.length; j < len; j++) {
  food = ref[j];
  eat(food);
}

// Fine five course dining.
courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];

menu = function(i, dish) {
  return `Menu Item ${i}: ${dish}`;
};

for (i = k = 0, len1 = courses.length; k < len1; i = ++k) {
  dish = courses[i];
  menu(i + 1, dish);
}

// Health conscious meal.
foods = ['broccoli', 'spinach', 'chocolate'];

for (l = 0, len2 = foods.length; l < len2; l++) {
  food = foods[l];
  if (food !== 'chocolate') {
    eat(food);
  }
}

// 返回值的例子转化为 Javascript 变得如此之长，可以看到 CoffeeScript 的精炼
var countdown, num;

countdown = (function() {
  var i, results;
  results = [];
  for (num = i = 10; i >= 1; num = --i) {
    results.push(num);
  }
  return results;
})();

// 遍历对象的例子
var age, ages, child, yearsOld;

yearsOld = {
  max: 10,
  ida: 9,
  tim: 11
};

ages = (function() {
  var results;
  results = [];
  for (child in yearsOld) {
    age = yearsOld[child];
    results.push(`${child} is ${age}`);
  }
  return results;
})();

```

特别地，CoffeScript 提供一个低级的 while 循环，它同样是带有返回值的。

```coffee
# Econ 101
if this.studyingEconomics
  buy()  while supply > demand
  sell() until supply > demand

# Nursery Rhyme
num = 6
lyrics = while num -= 1
  "#{num} little monkeys, jumping on the bed.
    One fell out and bumped his head."
```
```javascript
// Econ 101
var lyrics, num;

if (this.studyingEconomics) {
  while (supply > demand) {
    buy();
  }
  while (!(supply > demand)) {
    sell();
  }
}

// Nursery Rhyme
num = 6;

lyrics = (function() {
  var results;
  results = [];
  while (num -= 1) {
    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);
  }
  return results;
})();

```

JavaScript 老手可能会很习惯匿名函数立即执行的用法，CoffeeScript 用 do 关键字支持把循环和匿名函数立即执行结合起来：

```coffee
for filename in list
  do (filename) ->
    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']
      fs.readFile filename, (err, contents) ->
        compile filename, contents.toString()
```
```javascript
var filename, fn, i, len;

fn = function(filename) {
  if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {
    return fs.readFile(filename, function(err, contents) {
      return compile(filename, contents.toString());
    });
  }
};
for (i = 0, len = list.length; i < len; i++) {
  filename = list[i];
  fn(filename);
}

```

## 数组分片和 range 分片 ##

CoffeeScript 同样以索引操作符的形式（类 Python 和 C++）支持对数组的 slicing。

```coffee
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]

start   = numbers[0..2]

middle  = numbers[3...-2]

end     = numbers[-2..]

copy    = numbers[..]

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

numbers[3..6] = [-3, -4, -5, -6]
```
```javascript
var copy, end, middle, numbers, start;

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

start = numbers.slice(0, 3);

middle = numbers.slice(3, -2);

end = numbers.slice(-2);

copy = numbers.slice(0);

var numbers, ref,
  splice = [].splice;

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;
```

## 一切皆表达式 ##

表达式特别于普通语句的地方，就是它们总是可以求值的。
诸位读者可能已经注意到，CoffeeScript 中几乎没有 return。在函数中，最后一行表达式，就是整个块的表达式返回值，这点也是 CoffeeScript 从 Ruby 那里吸收来的特性。

```coffee
grade = (student) ->
  if student.excellentWork
    "A+"
  else if student.okayStuff
    if student.triedHard then "B" else "B-"
  else
    "C"

eldest = if 24 > 21 then "Liz" else "Ike"

six = (one = 1) + (two = 2) + (three = 3)

# The first ten global properties.

globals = (name for name of window)[0...10]
```
```javascript
var eldest, grade;

grade = function(student) {
  if (student.excellentWork) {
    return "A+";
  } else if (student.okayStuff) {
    if (student.triedHard) {
      return "B";
    } else {
      return "B-";
    }
  } else {
    return "C";
  }
};

eldest = 24 > 21 ? "Liz" : "Ike";

var one, six, three, two;

six = (one = 1) + (two = 2) + (three = 3);

// The first ten global properties.
var globals, name;

globals = ((function() {
  var results;
  results = [];
  for (name in window) {
    results.push(name);
  }
  return results;
})()).slice(0, 10);
```

比较有意思的是，try/catch 也是可以有返回值的：

```coffee
alert(
  try
    nonexistent / undefined
  catch error
    "And the error is ... #{error}"
)

```
```javascript
var error;

alert((function() {
  try {
    return nonexistent / void 0;
  } catch (error1) {
    error = error1;
    return `And the error is ... ${error}`;
  }
})());
```