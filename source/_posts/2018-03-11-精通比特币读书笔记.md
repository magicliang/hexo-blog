---
title: 精通比特币读书笔记
date: 2018-03-11 15:28:10
tags:
- 区块链
- 比特币
---
## 第一章 介绍 ##

传统货币的防止双花，必须在一个中心化（centralized）的清算所（clearing house）里清算。比特币则用全局选举的机制达到共识，来清算双花问题。本质上来讲，就是把一个固定的中心化的清算过程，用选举的方式转化为无数个去中心化的局部清算过程。这就弥补了在比特币之前出现的数字货币的缺点。 clearing 在比特币网络里就被称作 mining 。

钱包是保存地址和管理密钥的地方。不要害怕公开自己的钱包地址。

全节点可以获取全部的交易信息，也因此可以验证交易，发出交易。硬件钱包是运转在专有硬件上的节点（树莓派？），冷钱包就是纸一类的东西。离线钱包是非常安全的。

## 第二章 比特币原理

比特币最多可以分割到一亿分之一的大小。

Transaction就像是复式记账法账簿上的行，即每行都有输入和输出。

简单来说，每一笔交易包含一个或多个“输入”，输入是针对一个比特币账号的**提款**（而不是债务）。 这笔交易的另一面，有一个或多个“输出”，被当成信用点数记入到比特币账户中。这些输入和输出的总额（负债和信用）不需要相等。相反，当输出累加略少于输入量时，**两者的差额就代表了一笔隐含的“矿工费”**，这也是将交易放进账 簿的矿工所收集到的一笔小额支付。
![此处输入图片的描述][1]

简而言之，每个交易的输出是下一个交易的输入，意味着交易是编号的。

![交易是被编号的输入输出][2]

比特币中的找零（change），是经常会被发送到钱包的新地址里（出于隐私原因），或者返回原地址（出于默认配置）。

化零为整的例子：

![此处输入图片的描述][3]

化整为零的例子（发工资）：

![此处输入图片的描述][4]

钱包可以离线生成transaction。

> Alice只需要指定目标地址和金额，其余的 细节钱包应用会在后台自动完成。很重要的一点是，钱包应用甚至可以在完全离线时建立交易。就像在家里写张支票， 之后放到信封发给银行一样，比特币交易建立和签名时不用连接比特币网络。只有在执行交易时才需要将交易发送到网络。

钱包只存储与本地址相关 transaction，是所有数据的子集，是 filtered 过的。

> 大多数钱包应用跟踪着钱包中某个地址的所有可用输出。

查询某个地址的 UTXO，可以看到transaction 的格式，注意看，value的单位是聪（和以太坊一样，以太坊的value最小单位是伟）：

```
curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK
{
"unspent_outputs":[
{
"tx_hash":"186f9f998a5...2836dd734d2804fe65fa35779",
"tx_index":104810202,
"tx_output_n": 0,
"script":"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
"value": 10000000,
"value_hex": "00989680", 
"confirmations":0
}
]
}
```
这个格式里的 script就是锁定这个 UTXO的关键。这是一个留给未来使用这个UTXO的使用者的谜题-谁能拿出一个signature，可以和这个script里提供的锁定地址（也就是交易里的价值获得者）相匹配，就可以得到使用这个UTXO的权力。但这个script字段是什么意思呢？

value_hex 是 value 的16进制值。

私钥可以产生公钥，公钥可以散列出地址。交易里应该同时存在地址、签名和公钥。

> 交易被包在一起放进区块中时需要极大的计算量来证明，但只需少量计算 就能验证它们已被证明。

> 挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币很类似。

> 描述挖矿的一个好方法是将之类比为一个巨大的多人数独谜题游戏。一旦有人发现正解之后，这个数独游戏会自动调整 困难度以使游戏每次需要大约10分钟解决。想象一个有几千行几千列的巨大数独游戏。如果给你一个已经完成的数独， 你可以很快地验证它。然而，如果这个数独只有几个方格里有数字其余方格都为空的话，就会花费非常长的时间来解 决。这个数独游戏的困难度可以通过改变其大小（更多或更少行列）来调整，但即使它非常大时验证它也是相当容易 的。而比特币中的 "谜题" 是基于哈希加密算法的，其展现了相似的特性：非对称地，它解起来困难而验证很容易，并且它的困难度可以调整。

> 新交易不断地从用户钱包和应用流入比特币网络。当比特币网络上 的节点看到这些交易时，**会先将它们放到各自节点维护的一个临时的未经验证的交易池中**。。当矿工构建一个新区块时， 会将这些交易从这个交易池中拿出来放到这个新区块中，然后通过尝试解决一个非常困难的问题（也叫工作量证明）以 证明这个新区块的合法性。

工作量证明是为了证明这个区块是合法的。

>这些交易被加进新区块时，以交易费用高的优先以及其它的一些规则进行排序。矿工一旦从网络上收到一个新区块时， 会意识到在这个区块上的解题竞赛已经输掉了，会马上开始下一个新区块的挖掘工作。它会立刻将一些交易和这个新区块的数字指纹放在一起开始构建下一个新区块，并开始给它计算工作量证明。每个矿工会在他的区块中包含一个特殊的交易，将新生成的比特币（当前每区块为12.5比特币）作为报酬支付到他自己的比特币地址，再加上块中所有交易的交易费用的总和作为自己的报酬。如果他找到了使得新区块有效的解法，他就会得到这笔报酬，因为这个新区块被加入到了总区块链中，他添加的这笔报酬交易也会变成可消费的。

手续费（fee）的排序是存在的。

> Alice的交易被网络拿到后放进未验证交易池中。一旦被挖矿软件验证，它就被包含在由Jing的采矿池生成的新块（称为候选块）中。 参与该采矿池的所有矿工立即开始计算候选块的工作证明。大约 在Alice的钱包第一次将这个交易发送出来五分钟后，Jing的ASIC矿机发现了新区块的正解并将这个新区块发布到网络上后，一旦被其它矿机验证，它们就会立即投身到构建新区块的竞赛中。

所谓的候选区块也是存在的。

> 全索引客户端可以追钱款的来 源，从第一次有比特币在区块里生成的那一刻开始，按交易与交易间的关系顺藤摸瓜，直到Bob的交易地址。

特别地，轻客户端通过确认交易在哪个区块，以及后面还有多少个区块来确认一个**支付**的合法性。

在大多数情况下，UTXO总是是很难整齐地被拿来支付某些支出。总是很容易出现聚合（aggregating）几个 UTXO 用来支付一笔交易的情况。

## 第三章 比特币核心

最初的中本聪实现已经被吸收进了比特币核心，是其他比特币系统的参考实现。在这里bitcoin core就不是核心团队，而是核心系统了。

比特币核心架构图如下：

![比特币核心架构图][5]

不要使用比特币核心的钱包，应该使用支持标准（如BIP-39和BIP-32）的现代钱包。

在18年出，比特币核心需要2g的内存和160g的硬盘。比特币核心的节点会索引交易数据，这样应该可以提升一些搜索交易的速度。在下载完2009年以来全部的交易以前，比特币核心节点无法处理交易和更新余额（查账都做不到？）。

不想依赖其他人而验证交易的人总是需要一个自己的节点。

获取一个交易并且对它进行解码：

```
$ bitcoin-cli decoderawtransaction 0100000001186f9f998a5aa6f048e51dd8419a14d8↵
a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba474↵
6ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298↵
cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fd↵
e0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa↵
336a8d752adfffffffff0260e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5↵
d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8↵
88ac00000000

{
  "txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
  "size": 258,
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2...8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig": {
        "asm":"3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1decc...",
        "hex":"483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1de..."
      },
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 ab68...5f654e7 OP_EQUALVERIFY OP_CHECKSIG",
        "hex": "76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac",
        "reqSigs": 1,
        "type": "pubkeyhash",
        "addresses": [
          "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"
        ]
      }
    },
    {
      "value": 0.08450000,
      "n": 1,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 7f9b1a...025a8 OP_EQUALVERIFY OP_CHECKSIG",
        "hex": "76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
        "reqSigs": 1,
        "type": "pubkeyhash",
        "addresses": [
          "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK"
        ]
      }
    }
  ]
}

```

交易的实际存储总是十六进制编码。而总能解码为一个 JSON 对象。
注意看上面的交易细节，一个输入产生了两个输出，一个是真实转账，一个是找零转账，实际上应该也可以支持多个输入。vin则是上一次交易，可以看到上一次交易也有散列形式的txid。

> 提示交易ID在交易被确认之前不具有权威性。 在区块链中缺少交易哈希并不意味着交易未被处理。 这被称为“交易可扩展性”，因为在块中确认之前可以修改交易哈希。 确认后，txid是不可改变的和权威的。

这段话的意思，恐怕是赞同交易可扩展性的，但交易可扩展性明明是有问题的。

块可以由块高度或块哈希引用。

用块高度可以得到块散列，用块散列可以得到块内容。

```
$ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b3↵
1b2cc7bdc4

{
  "hash": "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
  "confirmations": 37371,
  "size": 218629,
  "height": 277316,
  "version": 2,
  "merkleroot": "c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e",
  "tx": [
    "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
    "b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe",
    "04905ff987ddd4cfe603b03cfb7ca50ee81d89d1f8f5f265c38f763eea4a21fd",
    "32467aab5d04f51940075055c2f20bbd1195727c961431bf0aff8443f9710f81",
    "561c5216944e21fa29dd12aaa1a45e3397f9c0d888359cb05e1f79fe73da37bd",
[... hundreds of transactions ...]
    "78b300b2a1d2d9449b58db7bc71c3884d6e0579617e0da4991b9734cef7ab23a",
    "6c87130ec283ab4c2c493b190c20de4b28ff3caf72d16ffa1ce3e96f2069aca9",
    "6f423dbc3636ef193fd8898dfdf7621dcade1bbe509e963ffbff91f696d81a62",
    "802ba8b2adabc5796a9471f25b02ae6aeee2439c679a5c33c4bbcee97e081196",
    "eaaf6a048588d9ad4d1c092539bd571dd8af30635c152a3b0e8b611e67d1a1af",
    "e67abc6bd5e2cac169821afc51b207127f42b92a841e976f9b752157879ba8bd",
    "d38985a6a1bfd35037cb7776b2dc86797abbb7a06630f5d03df2785d50d5a2ac",
    "45ea0a3f6016d2bb90ab92c34a7aac9767671a8a84b9bcce6c019e60197c134b",
    "c098445d748ced5f178ef2ff96f2758cbec9eb32cb0fc65db313bcac1d3bc98f"
  ],
  "time": 1388185914,
  "mediantime": 1388183675,
  "nonce": 924591752,
  "bits": "1903a30c",
  "difficulty": 1180923195.258026,
  "chainwork": "000000000000000000000000000000000000000000000934695e92aaf53afa1a",
  "previousblockhash": "0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569",
  "nextblockhash": "000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"
}
```

当然除了命令行的方式，也可以有各种各样的客户端来实现比特币的全节点。

## 第四章 密钥和地址

现代密码学的用处：

- 秘密写作
- 用签名来证明秘密
- 用数字指纹来证明数据真实性

> 具有讽刺意味的是，加密不是比特币的重要组成部分，**因为它的通信和交易数据没有加密**，也不需要加密来保护资金。 

公开通信，公开存储，所以所有人都可以查看。

> 大多数比特币交易都需要一个有效的签名才会被存储在区块链。只有有效的密钥才能产生有效的数字签名，因此拥有~密钥副本就拥有了对该帐户的比特币的控制权。用于支出资金的数字签名也称为见证（witness），密码术中使用的术语。 比特币交易中的见证数据证明了所用资金的真正归谁所有。

有签名才有见证，隔离见证即隔离签名相关部分。

密钥是成对出现的，由一个私钥和一个公钥所组成。公钥就像银行的帐号，而私钥就像控制账户的PIN码或支票的签名。

一般而言，由公钥生成的地址对应公钥。但比特币地址并不只能代表公钥，它还可以代表其他支付对象，譬如脚本。**比特币地址把收款方抽象起来了。**

公钥加密发明于上个世纪70年代。

素数幂和椭圆曲线乘法函数，在数学上都是不可逆的。

在比特币系统中，我们用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥，和由其衍生出的唯 一的公钥。公钥用于接收比特币，而私钥用于比特币支付时的交易签名。

私钥->公钥->地址。

公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。**此签名可以在不泄露私钥的同时对公钥进行验证**，大致是通过`OP_CHECKSIG`一类操作码。

> 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（**每次交易的签名都不同，但均从同一个私钥生 成**）。比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。

我们通常可以随机选择一个数字(k)作为私钥，然后通过椭圆曲线相乘算法得到一个公钥(K)。然后使用一个单向散列函数得到一个地址（A）。

![私钥生成公钥，公钥生成地址][6]

> 为什么在比特币中使用非对称密码学？ 它不是用于“加密”（make secret）交易。相反，非对称密码学的有用属性是生成数字签名的能力。 可以将私钥应用于交易的数字指纹以产生数字签名。 该签名只能由知晓私钥的人生成。

换言之，只有非对称加密才能在确保私钥保密的情况下产生签名。私钥就是一个随机选出的数字而已。一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权。

> 你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。该私钥可进一步生成公钥。

生成一个比特币私钥在本质上与“在1 到2^256之间选一个数字”无异。

> 更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158 * 10^77，略小于2^256），并被定义为由比特币所使用的椭圆曲线的阶（见椭圆曲线密码学解释）。要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。

> 要使用比特币核心客户端生成一个新的密钥，可使用 getnewaddress 命令。出于安全考虑，命令运行后只 显示生成的公钥，而不显示私钥。如果要bitcoind显示私钥，可以使用 dumpprivkey 命令。 dumpprivkey 命令会把私钥以 Base58校验和编码格式显示，这种私钥格式被称为钱包导入格式（WIF，Wallet Import Format）

为什么与私钥签名有关的编码都是 Base58 编码？

> 通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。在演示如何从私钥生成公钥之前，我们先稍微详细学习下椭圆曲线密码学。

因为所有比特币用户的生成点是相同的，一个私钥k乘以G将 得到相同的公钥K。

比特币的地址总是1开头的。它本质上只是公钥的指纹。公钥的计算方法是双层散列。以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160位（20字节）的数字：

A = RIPEMD160(SHA256(K))

但我们常见的比特币地址还更近一层，使用了一个 Base58Check 的机制，提供了一个可读的、有校验和的版本。

![公钥生成地址的过程][7]

> Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错 读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“/”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。

> 为了增加防止打印和转录错误的安全性，Base58Check是一种常用在比特币中的Base58编码格式，比特币有内置的检查错误的编码。检验和是添加到正在编码的数据末端的额外4个字节。校验和是从编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。使用Base58check编码时，解码软件会计算数据的校验和并和编码中自带的校验和进行对比。二者不匹配则表明有错误产生，那么这个Base58Check的数据就是无效的。一个错误比特币地址就不会被钱包软件认为是有效的地址，否则这种错误会造成资金的丢失。

换言之，比特币地址的最后两个8个字符是校验和？

> 为了将数据（数字）转换成Base58Check格式，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来识别编码的数据的类 型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。

> 接下来，我们计算“双哈希”校验和，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法：

> checksum = SHA256(SHA256(prefix+data))

> 在产生的长32个字节的哈希值（两次哈希运算）中，我们只取前4个字节。这4个字节就作为检验错误的代码或者校验和。校验码会添加到数据之后。

为什么头四个字节就可以拿来当校验和并说明数据变化？

所以比特币的 Base58Check 地址，是一个加头（1字节）加尾（四字节）的数据。

![Base58Check 的过程][8]
注意，这个图的上半部分是增加Check的过程，加头加尾以后还要 Base58 Encoding才行。

Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的。下图展示了一些版本前缀和他们对应的Base58格式：



## 第五章 钱包
## 第六章 交易
## 第七章 高级交易和脚本
## 第八章 比特币网络
## 第九章 区块链
## 第十章 挖矿和共识
## 第十一章 比特币安全
## 第十二章 比特币应用


  [1]: https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0203.png
  [2]: https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0204.png
  [3]: https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0206.png
  [4]: https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0207.png
  [5]: https://camo.githubusercontent.com/50a3df5a5d7ce206496a575f00a202d853fe254e/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d663236616164373238663461393037662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430
  [6]: https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0401.png
  [7]: https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0405.png
  [8]: https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0406.png