---
title: MySQL 中的日志
date: 2020-07-20 16:07:52
tags:
- MySQL
- 数据库
---
# Binlog

## 初始定义

BinLog 是记录 MySQL 实例数据变更的一个组件，日志中包含了一系列变更数据的操作，例如变更表结构、删除数据、更改/添加数据等 DML、DDL。这些操作在 BinLog 中统称为事件。

## BinLog 记录什么，不记录什么

BinLog 也会记录一些可能会发生数据变更的事件，例如没有找到对应行的 Delete 操作。

BinLog 不会记录纯查询，如 Select 和 Show。那要查询所有语句的记录怎么办（比如要分析长事务）？需要查找[通用查询日志][1]。

## 用途

 - 主从同步：在主从同步的过程中，Binlog用于记录主库的数据变更，然后这些记录被主库内的**线程**发送至从库。从库的**工作线程**再把接收到的变更事件放到从库上执行，完成数据同步。主从同步通常被视为提升数据库吞吐能力的一种方法，因此Binlog是必不可少的环节。
 - 数据恢复： 在生产环境中，总是会有意外导致数据丢失。在一些数据恢复的场景中，Binlog是必不可少的。当数据库从备份中恢复的时候，binlog中所记录的信息会在恢复后的数据上执行，补齐备份数据中未备份的记录。**注意，这里的数据恢复不包括数据回滚，回滚依赖于 undo-log。**

## BinLog 结构

![binlog-structure.png](binlog-structure.png)

从上图可以看出，一个完整的binlog由两种文件组成

1. 索引文件(Index File)：

索引文件用于跟踪多个binlog文件，便于主库创建新的binlog文件。索引文件中的每一行记录着所有关联和它关联的binlog文件名。在系统中，索引文件的文件名为{Host名}-bin.index

2. 日志文件(Binlog file)：

![bin-log-file.png](bin-log-file.png)

日志文件是binlog的主体，如上图所示，它是由一系列事件(Binary Log Events)组成。在系统中，文件名为{Host名}-bin.NNNNNN。 后缀为六个数字用于区分不同的日志文件。

日志文件的开头记录的是的是 Format_description 事件，这个事件记录主库的信息和日志文件的状态。如果主库突然宕机或者重启，主库会重新创建一个日志文件然后在开头写入Format_description。
当主库记录完成变更事件后，主库会写入Rotate事件。Rotate事件会指定下一个日志文件的文件名和读取事件的起始点。

## BinLog 分组

除开上述的Format_description事件和Rotate事件，日志文件都会把其他的变更事件进行分组(Group)。在MySQL中，每一个事务会被分成一组，组中包含了这个事务下执行的所有语句。一些非事务性语句会被单独分成一组，如Create和Alter语句等。如下图所示：

![bin-log-group.png](bin-log-group.png)

MySQL能确保每一组变更的原子性，要么不执行，要么执行完每一个组的所有语句。在主从同步中，如果从库在同步过程突然中止，当从库重新启动后，从库会重新执行一个组的变更，而不是重新执行被终止的语句。如图中所示，当update被终止后，从库下次启动时会从Begin开始执行而不是从update开始执行（原子性会从 begin 开始，所以事务里的语句总是幂等的）。

## 日志格式

上个部分我们介绍了binlog日志的结构，知道每一个binlog日志是由多个事件组成的。为了方便阐述，文中默认每个事件都是执行的语句或者一个完整事务。在早期的MySQL版本中，这是binlog日志唯一的格式。自从MySQL5.1起，日志的格式增加到了三种：

1. **Statement-based（我们实际上最习惯的是这种语句）**： 这是MySQL默认的日志格式。在这个格式下，binlog日志中记录的是变更数据库的执行语句和事务。

2. **Row-based**:  在这个格式下，binlog日志中记录的是发生变更的数据行。

3. Mixed-logging: 这个格式是前两种格式的混合版，主库会根据执行的语句来决定binlog日志中记录的内容，可以是具体的行，也可以是执行的语句。

**其实 Row-based 的 binlog 的设计逻辑近于 balance 数据（或者状态数据），而 Statement-based 的设计逻辑近于 transaction 数据（或者流水数据）。**

每个日志格式都有其对应的优缺点，因为mixed-logging在实际生产环境中不常用。在这里仅对row-based和statement-based做比较，总结如下表：

|格式|优点|缺点|
|:--:|:--:|:--:|
|Statement-based|1. 较少的日志大小 2. 因为记录了所有执行语句，所以可以方便的做后期审计。|不适用于包含以下函数的语句：如USER(), UUID(), UUID_SHORT(), NOW()
不适用于不稳定的语句，如带Limit的Delete和Update语句|
|Row-based|1. 记录了所有实际变更的数据，准确性高
2. 对于Insert, update 和 delete语句，所需要的行锁大大降低|日志文件大，IO耗费较大|

## 日志事件结构

![log-event-structure.png](log-event-structure.png)

每个 binlog 事件由四个部分组成：

1. 通用 Header：这里存放事件的基本信息：事件类型和事件数据大小。
2. Post Header：存放特定事件类型的相关信息。
3. 事件实体：存储事件的数据，如执行过的语句和变更的实际数据。
4. Checksum：MySQL 5.6 新增的功能，用作检查数据是否损坏。

## 主从同步

mysql主从复制需要三个线程：master（binlog dump thread）、slave（I/O thread 、SQL thread）：

binlog dump线程：主库中有数据更新时，根据设置的binlog格式，将更新的事件类型写入到主库的binlog文件中，并创建log dump线程通知slave有数据更新。当I/O线程请求日志内容时，将此时的binlog名称和当前更新的位置同时传给slave的I/O线程。

I/O线程：该线程会连接到master，向log dump线程请求一份指定binlog文件位置的副本，并将请求回来的binlog存到本地的relay log中。

SQL线程：该线程检测到relay log有更新后，会读取并在本地做redo操作，将发生在主库的事件在本地重新执行一遍，来保证主从数据同步。

![主从复制1.png](主从复制1.png)

1. 主库写入数据并且生成binlog文件。该过程中MySQL将事务串行的写入二进制日志，即使事务中的语句都是**交叉执行的（binlog 的生成有将事物序列化的机制）**。
2. 在事件写入二进制日志完成后，master 通知存储引擎提交事务（**binlog 也是 WAL！**）。
3. 从库服务器上的 IO 线程连接 Master 服务器，请求从执行 binlog 日志文件中的指定位置开始读取 binlog 至从库。
4. 主库接收到从库的 IO 线程请求后，其上复制的 IO 线程会根据 Slave 的请求信息分批读取 binlog 文件然后返回给从库的IO线程。
5. Slave服务器的IO线程获取到 Master 服务器上 IO 线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到 Slave 端自身的 Relay Log（即中继日志）文件的最末端，并将新的 binlog 文件名和位置记录到 master-info 文件中，以便下一次读取 master 端新binlog日志时能告诉 Master 服务器从新 binlog 日志的指定文件及位置开始读取新的 binlog 日志内容。
6. 从库服务器的 SQL 线程会实时监测到本地Relay Log中新增了日志内容，然后把 RelayLog 中的日志翻译成SQL并且按照顺序执行SQL来更新从库的数据。
7. 从库在relay-log.info中记录当前应用中继日志的文件名和位置点以便下一次数据复制。

主从复制的线程流程，和 Redis 的线程有点像。

![主从复制2.png](主从复制2.png)

Binlog是主从同步中的重要一环，如上图所示。

不同的binlog日志格式会影响从库的同步方式。在statement-based格式下，从库是直接执行binlog日志中读取到的语句或者事务。在row-based格式下，从库是根据日志内容直接更新对应的数据。

MySQL默认的日志格式是statement-based。在大多数主从同步的场景下，日志格式采用row-based**（大多数情况下不使用默认配置）**，最主要的原因是row-based格式下，日志内容都是真实发生变更的数据，从库的数据准确性有很高的保证。


## 数据恢复

在生产环境中，数据很有可能发生意外丢失。人为的操作失误往往会导致“删库跑路”的结局。为了应对各种意外的情况，数据库会周期性的做备份。当数据意外丢失后，备份数据可以拿过来恢复。然而，即使数据做了备份，也不能完全恢复到丢失那一刻的数据。

> 假设某数据库每一个整点备份一次，上午10点数据库备份了一次，而10：30分，数据库突然丢失数据。
> 
> 这时候我们会立刻拿备份数据导入到生产数据库中，然而我们只能恢复到上午10点时的数据，10：00 ~
> 10：30那段时间的数据并没有被导入备份，还是会缺失一部分数据。
> 
> 所以，这30分钟的数据怎么恢复呢？

这里就用到了 MySQL 的Point-In-time recovery(简称PITR)功能，PITR是用于恢复某个时间点的失效数据，用于弥补备份时间点到失效时间点这段数据“真空期”，实现这个功能的核心是binlog日志文件。

在详解binlog日志时我们了解到，binlog日志中存放着数据库所有的变更。PITR的原理很简单，就是将binlog内存储的变更数据重新执行一遍。需要恢复数据时，用mysqlbinlog命令执行binlog日志的内容。

```bash
-- mysqlbinlog 也可以手动执行
mysqlbinlog binlog_files | mysql -u root -p
```

PITR可以选定时间范围和位置范围来选择性恢复数据：

1. 时间范围模式，使用--start-datetime或者--stop-datetime 变量。下图的含义是读取该binlog日志stop-datetime之前的所有变更：

```bash
mysqlbinlog --stop-datetime="2005-04-20 9:59:59" \
         /var/log/mysql/bin.123456 | mysql -u root -p
```
2. 日志位置模式，使用--start-position和 --stop-position 变量选择日志内的起始位置，如下图：

```bash
-- 指定停止位置
mysqlbinlog --stop-position=368312 /var/log/mysql/bin.123456 \
         | mysql -u root -p
-- 指定开始位置
mysqlbinlog --start-position=368315 /var/log/mysql/bin.123456 \
         | mysql -u root -p
```

## Binlog 不同于 Redo log

redo log有着和binlog 类似的功能，它也记录了变更数据库的信息，但是它和binlog还是有区别的，具体区别如下：

|日志类型|Bin Log|Redo Log|
|:--:|:--:|:--:|
|层次|引擎无关（MySQL 总是有 Bin Log）|InnoDB 特有|
|作用|主从复制和 PITR| 数据库崩溃后的恢复，不可指定具体时间点（**单独恢复若干个事务**）|
|内容|逻辑日志，记录语句的原始逻辑**（更加接近我们熟悉的操作日志）**|物理日志，记录某个数据页上的修改|

## 丢失 binlog 造成的事故

1. binlog 的文件如果有滚动功能，就有限期清理的功能。如果限期清理的日志不足以提供 PITR 的所有支持，则无法支持备份的还原。也无法支持主从同步。如果数据在从库上丢了，在主库上进行回滚也是一种思路。

## 主从延迟的原因

1、从库的机器性能比主库要差

比如将20台主库放在4台机器，把从库放在一台机器。这个时候进行更新操作，由于更新时会触发大量读操作，导致从库机器上的多个从库争夺资源，导致主从延迟。

不过，目前大部分部署都是采取主从使用相同规格的机器部署。

2、从库的压力大

按照正常的策略，读写分离，主库提供写能力，从库提供读能力。出于对于主库的敬畏之心，将进行大量查询放在从库上，结果导致从库上耗费了大量的CPU资源，进而影响了同步速度，造成主从延迟。

对于这种情况，可以通过一主多从，分担读压力；也可以采取binlog输出到外部系统，比如Hadoop，让外部系统提供查询能力。

3、大事务的执行

一旦执行大事务，那么主库必须要等到事务完成之后才会写入binlog。

如：主库执行了一条insert … select非常大的插入操作，该操作产生了近几百G的binlog文件传输到只读节点，进而导致了只读节点出现应用binlog延迟。

因此，DBA经常会提醒开发，不要一次性地试用delete语句删除大量数据，尽可能控制数量，分批进行。

4、主库的DDL(alter、drop、repair、create)

1、只读节点与主库的DDL同步是串行进行，如果DDL操作在主库执行时间很长，那么从库也会消耗同样的时间，比如在主库对一张500W的表添加一个字段耗费了10分钟，那么只读节点上也会耗费10分钟。

2、只读节点上有一个执行时间非常长的的查询正在执行，那么这个查询会堵塞来自主库的DDL，读节点表被锁，直到查询结束为止，进而导致了只读节点的数据延迟。

5、锁冲突

锁冲突问题也可能导致从机的SQL线程执行慢，比如从机上有一些select  ....  for update的SQL，或者使用了MyISAM引擎等。

6、从库的复制能力

一般场景中，因偶然情况导致从库延迟了几分钟，都会在从库恢复之后追上主库。但若是从库执行速度低于主库，且主库持续具有压力，就会导致长时间主从延迟，很有可能就是从库复制能力的问题。

回头再看下主从复制的流程，主要看下红色的箭头：

 1、上面两个箭头分别表示的是客户端写入主库和sql_thread执行relaylog，若粗细表示并发度，可见主库明显高于从库。

 2、从库上的执行，即sql_thread更新逻辑，在5.6版本之前，是只支持单线程，那么在主库并发高、TPS高时，就会出现较大的主从延迟。 

因此，在随后演进的版本中，官方的 MySQL提出了不断改进的多线程复制方法，用于减少主从延迟。

## 并行复制的原理

### 多线程复制

![并行复制.png](并行复制.png)



# Redo/Undo log


  [1]: https://dev.mysql.com/doc/refman/5.7/en/query-log.html
