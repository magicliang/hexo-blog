---
title: MySQL 索引问题
date: 2020-02-19 21:03:17
tags:
- MySQL
---
# explain 思维导图

![MySQl Explain.png](MySQl Explain.png)
[MySQl Explain.xmind](MySQl Explain.xmind)

# 与 id 的关系

辅助索引如果没有触发 Using Index 要回表，使用 id 不需要回表。

# 索引选择

多个索引同时存在，也每次只能使用一个索引。有重叠的索引，如 status、status + time 可能导致任一索引不被使用，有时候单一索引反而更简单。因为添加索引的字段一定要有很好的区分度【cardinality】，区分度不够的时候回表的开销不如 all（full table scan）。

数据量小(比如小于2000 时)的时候 type 可能会是 all，即不走索引直接全表扫描，原理是类似 pg 和 oracle 的 cost-based optimizer。

using index condition 不是 using index，还是可能回表。

# 与 order by 的关系

1、如果你只需要结果集中的某几行，那么建议使用limit。这样这样的话可以避免抓取全部结果集，然后再丢弃那些你不要的行。

2、对于order by查询，带或者不带limit可能返回行的顺序是不一样的。

3、如果limit row_count 与 order by 一起使用，那么在找到第一个row_count就停止排序，直接返回。

4、如果order by列有相同的值，那么MySQL可以自由地以任何顺序返回这些行。换言之，只要order by列的值不重复，就可以保证返回的顺序。

5、可以在order by子句中包含附加列(组合 order by)，以使顺序具有确定性。

6、ORDER BY的索引优化。如果一个SQL语句形如：
SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort];
在[sort]这个栏位上建立索引就可以实现利用索引进行order by 优化。相反地，如果 order by 没有命中索引，就会导致 file sort，mysql 5.7 也不例外。但很多时候，没有命中索引，也不一定就会慢，命中索引或多或少都会导致回表，有可能不回表的速度更快-这取决于 query optimizer 怎么看待这个查询计划。考虑多方诉求的话，可以打破常规，考虑把 id 加进索引里。

7、WHERE + ORDER BY的索引优化，形如：
SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort];
建立一个联合索引(columnX,sort)来实现order by 优化。

注意：如果columnX对应多个值，如下面语句就无法利用索引来实现order by的优化
SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY[sort];

8、WHERE+ 多个字段ORDER BY
SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;
建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。

MySQL Order By不能使用索引来优化排序的情况
* 对不同的索引键做 ORDER BY ：(key1,key2分别建立索引)
SELECT * FROM t1 ORDER BY key1, key2;

* 在非连续的索引键部分上做 ORDER BY：(key_part1,key_part2建立联合索引;key2建立索引)
SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2;

* 同时使用了 ASC 和 DESC：(key_part1,key_part2建立联合索引)
SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;

* 用于搜索记录的索引键和做 ORDER BY 的不是同一个：(key1,key2分别建立索引)
SELECT * FROM t1 WHERE key2=constant ORDER BY key1;

* 如果在WHERE和ORDER BY的栏位上应用表达式(函数)时，则无法利用索引来实现order by的优化
SELECT * FROM t1 ORDER BY YEAR(logindate) LIMIT 0,10;

特别提示:
1>mysql一次查询只能使用一个索引。如果要对多个字段使用索引，建立复合索引。
2>在ORDER BY操作中，MySQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。

9、[如果不指定 ORDER BY，不能指望 mysql 默认返回任何默认顺序][1]。但一旦指定了 order by，[MySQL 的 order by 的默认值是 asc][2]。

10、 MySQL 8.0 开始支持[索引在磁盘上排序][3] 。

11、Databases can read indexes in both directions. 但，如果走索引的列和 order by 的列正好相反，那么查询会非常非常慢。举例，假设 t 的数据量非常大，`select * from t where gmt_create < '2019-08-11 22:00:00' order by id`，如果 MySQL 的查询优化器决定使用 id作为索引（MySQL 上每次只有一个索引会生效），那么查询会先从主索引的树的左边往右扫（**扫描顺序由 order by 的顺序决定**），如果当前时间和 2019-08-11 22:00:00 之间的数据量非常大，会导致非常大的 filtered，查询会异常地慢（这种情况有点类似 index jumping-注意看这个[例子][4]的 6.3）。

  [1]: https://dba.stackexchange.com/questions/6051/what-is-the-default-order-of-records-for-a-select-statement-in-mysql#comment498655_6053
  [2]: https://dev.mysql.com/doc/refman/8.0/en/sorting-rows.html
  [3]: https://www.percona.com/blog/2016/10/20/mysql-8-0-descending-indexes-can-speedup-your-queries/
  [4]: https://use-the-index-luke.com/sql/sorting-grouping/order-by-asc-desc-nulls-last
