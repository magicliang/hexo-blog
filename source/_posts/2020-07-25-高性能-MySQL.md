---
title: 高性能 MySQL
date: 2020-07-25 09:57:21
tags:
- 高性能
- MySQL
---
# 译者序

MySQL 最初是放在 LAMP 里一起讨论。

淘宝网最初使用 LAMP 架构，使用 MySQL 4.0。03 年底改用 IOE，从 08 年开始又筹划去 IOE。09 年的时候 MySQL 的架构也从垂直拆分改成水平拆分。2012 年 MySQL 的单库已经有了 6.5 万的 QPS。

本书是 mysqlperformanceblog.com 的几个专家（同样也是 percona 的创始人）的作品，对于 InnoDB/XtraDB 等存储引擎的性能优化和诊断方法有很深入和详细的介绍。

# 推荐序

作者在性能优化领域工作多年，这本书诞生于 MySQL 还没有什么可扩展性和可测量性的时代，直到现在这些方面已经有了长足的进步。说到合理的方法，他们简直把这件事当成了科学，**首先定义需要解决的问题，然后通过合理的猜测和精确的测量来解决问题**。

性能优化 = 定义问题 + 猜测 + 测量

要关注：

 - 吞吐量
 - 响应时间

吞吐量 = 线程数/响应时间

追求新技能，如排队理论对性能的影响。

# MySQL 的架构和历史

MySQL 能够应用的场景：

 - 嵌入到应用程序中
 - 数据仓库
 - 内容索引
 - 部署软件
 - 高可用的冗余系统
 - 在线事务处理系统

MySQL 最重要、最与众不同的特性是它的存储引擎架构，这种设计将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储/提取相分离。

## MySQL 的逻辑架构

第一层：client + connector。连接处理、授权认证、安全等等。
第二层：Server。职责是：实现函数、查询解析、缓存、优化，所有的跨存储引擎的功能都在这一层实现，包括存储过程、触发器、视图。
第三层：storage engine。实现数据的存储和提取。每个引擎都互有优势（pros）和劣势（cons）。server 和 storage engine 之间通过统一的**接口 API 进行通信**。存储引擎层不解析 SQL。

### 连接管理和安全性

（在 Server 层）每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个 CPU 核心或者 CPU 中运行。服务器会缓存线程，不必为每个新建的连接创建和销毁线程（**常见的设计模式，要考虑伸缩性，和线程池的分层**）。MySQL 还支持 SSL 连接，所以具有使用 X.509 认证的能力。

Server 层有自己的 privilege 模型。

### 优化与执行

MySQL 会解析查询，并创建内部数据结构（AST），然后对其进行各种优化，包括：

- 重写查询
- 决定表的读写顺序
- 选择合适的索引

用户可以通过特殊的关键字提示器（hint），影响它的决策过程，也可以通过解释器（explain）来理解 server 是怎样决策的。

用户可以优化：

 - 查询
  - 优化索引
  - 优化其他查询条件
  - 优化翻页
  - 优化排序
 - schema
 - 配置

进而使应用可以高效运行。

优化器并不关心使用什么存储引擎，但存储引擎会影响优化器。优化器会询问存储引擎一些统计信息，包括但不局限于存储容量、具体操作的开销信息、表的统计信息，进行一些类似 cost-based 的优化。

对于 select 语句，在**解析查询以前**，Server 层会先检查查询缓存（Query Cache），如果能够找到对应的查询，则不再进入 parser、optimizer 和 execution 的全过程。**这要求 server 层能够很好地控制 cache 的 consistency**。

## 并发控制（Concurrency Control）

理论上只要有多个查询（**事务或者事务里的语句**）在同一时刻修改数据，都会产生并发控制问题（另一种的 Race Condition）。

邮箱的例子：邮件如果是单链表，并发访问可能导致数据结构的分叉。所以基本的方案必须通过加锁来维护数据结构的正确性（也就是业务的正确性）。然而加锁的方案只是基础方案，不是一个高性能方案。**高性能方案应该是混合使用 lock 和 lock-free 的方案**。

### 读写锁

读通常没有问题，但通常的业务逻辑总是读写混合的。所以锁系统应该提供差异化的读锁（share lock）和写锁（exclusive lock）。

读锁相互共享。
写锁相互阻塞。

### 锁力度

**尽量只锁定需要修改的部分数据 - 只对修改的数据片进行精确的锁定**，是在并发力度下性能最优的锁定策略，可以尽量避免锁冲突（lock contest）。

锁本身也需要资源，这部分的性能开销往往为人所忽略。

在存储引擎的设计中，锁管理是个非常重要的决定。将锁固定在某个级别，可以为某个应用场景提供更好的性能，但同时会支持对另外一些应用场景的良好的支持。但 MySQL 支持多种存储引擎，所以不需要单一的通用解决方案。

#### 表锁（table lock）



#### 行锁（row lock）

