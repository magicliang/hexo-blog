---
title: 高性能 MySQL
date: 2020-07-25 09:57:21
tags:
- 高性能
- MySQL
---
# 译者序

MySQL 最初是放在 LAMP 里一起讨论。

淘宝网最初使用 LAMP 架构，使用 MySQL 4.0。03 年底改用 IOE，从 08 年开始又筹划去 IOE。09 年的时候 MySQL 的架构也从垂直拆分改成水平拆分。2012 年 MySQL 的单库已经有了 6.5 万的 QPS。

本书是 mysqlperformanceblog.com 的几个专家（同样也是 percona 的创始人）的作品，对于 InnoDB/XtraDB 等存储引擎的性能优化和诊断方法有很深入和详细的介绍。

# 推荐序

作者在性能优化领域工作多年，这本书诞生于 MySQL 还没有什么可扩展性和可测量性的时代，直到现在这些方面已经有了长足的进步。说到合理的方法，他们简直把这件事当成了科学，**首先定义需要解决的问题，然后通过合理的猜测和精确的测量来解决问题**。

性能优化 = 定义问题 + 猜测 + 测量

要关注：

 - 吞吐量
 - 响应时间

吞吐量 = 线程数/响应时间

追求新技能，如排队理论对性能的影响。

# MySQL 的架构和历史

MySQL 能够应用的场景：

 - 嵌入到应用程序中
 - 数据仓库
 - 内容索引
 - 部署软件
 - 高可用的冗余系统
 - 在线事务处理系统

MySQL 最重要、最与众不同的特性是它的存储引擎架构，这种设计将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储/提取相分离。

## MySQL 的逻辑架构

第一层：client + connector。连接处理、授权认证、安全等等。
第二层：Server。职责是：实现函数、查询解析、缓存、优化，所有的跨存储引擎的功能都在这一层实现，包括存储过程、触发器、视图。
第三层：storage engine。实现数据的存储和提取。每个引擎都互有优势（pros）和劣势（cons）。server 和 storage engine 之间通过统一的**接口 API 进行通信**。存储引擎层不解析 SQL。

### 连接管理和安全性

（在 Server 层）每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个 CPU 核心或者 CPU 中运行。服务器会缓存线程，不必为每个新建的连接创建和销毁线程（**常见的设计模式，要考虑伸缩性，和线程池的分层**）。MySQL 还支持 SSL 连接，所以具有使用 X.509 认证的能力。

Server 层有自己的 privilege 模型。

### 优化与执行

MySQL 会解析查询，并创建内部数据结构（AST），然后对其进行各种优化，包括：

- 重写查询
- 决定表的读写顺序
- 选择合适的索引

用户可以通过特殊的关键字提示器（hint），影响它的决策过程，也可以通过解释器（explain）来理解 server 是怎样决策的。

用户可以优化：

 - 查询
  - 优化索引
  - 优化其他查询条件
  - 优化翻页
  - 优化排序
 - schema
 - 配置

进而使应用可以高效运行。

优化器并不关心使用什么存储引擎，但存储引擎会影响优化器。优化器会询问存储引擎一些统计信息，包括但不局限于存储容量、具体操作的开销信息、表的统计信息，进行一些类似 cost-based 的优化。

对于 select 语句，在**解析查询以前**，Server 层会先检查查询缓存（Query Cache），如果能够找到对应的查询，则不再进入 parser、optimizer 和 execution 的全过程。**这要求 server 层能够很好地控制 cache 的 consistency**。

## 并发控制（Concurrency Control）

理论上只要有多个查询（**事务或者事务里的语句**）在同一时刻修改数据，都会产生并发控制问题（另一种的 Race Condition）。

邮箱的例子：邮件如果是单链表，并发访问可能导致数据结构的分叉。所以基本的方案必须通过加锁来维护数据结构的正确性（也就是业务的正确性）。然而加锁的方案只是基础方案，不是一个高性能方案。**高性能方案应该是混合使用 lock 和 lock-free 的方案**。

### 读写锁

读通常没有问题，但通常的业务逻辑总是读写混合的。所以锁系统应该提供差异化的读锁（share lock）和写锁（exclusive lock）。

读锁相互共享。
写锁相互阻塞。

### 锁力度

**尽量只锁定需要修改的部分数据 - 只对修改的数据片进行精确的锁定**，是在并发力度下性能最优的锁定策略，可以尽量避免锁冲突（lock contest）。

锁本身也需要资源，这部分的性能开销往往为人所忽略。

在存储引擎的设计中，锁管理是个非常重要的决定。将锁固定在某个级别，可以为某个应用场景提供更好的性能，但同时会支持对另外一些应用场景的良好的支持。

最容易被忽略也最常见的表锁的使用场景，Alter Table - 所以需要 online ddl 工具的支持。

**server 层可以自己实现表锁，存储引擎层也可以实现表锁。server 层的表锁可以直接忽略存储引擎层的表锁。**

### 行级锁

行级锁可以最大程度地支持并发处理（同时也带来了最大的**锁开销**）。

只有存储引擎层可以实现行级锁。

## 事务

在理解事务以前，接触数据库的其他高级特性言之尚早。

事务就是一组原子性的 SQL 查询，或者一个独立的工作单元。事务其实是所有 statement 的组。

银行的模型，saving 和 checking，需要三个步骤：

1. 检查支票账户的余额高于 200 美元。
2. 从支票账户的余额中减去 200 美元。
3. 在储蓄账户的余额中加入 200 美元。

```SQL
-- 等同于 BEGIN
START TRANSACTION;
// 业务逻辑
COMMIT;
```

ACID 的标准定义：

### 原子性

一个事务必须被视为一个不可分割的最小工作单元。

### 一致性

数据库总是从一个一致性的状态，转换到另外一个一致性的状态。

### 隔离性

事务的修改在最终提交以前，对其他事务是不可见的。

### 持久性

一旦事务提交，则修改可以被永久保存到数据库中。即使系统崩溃，变更后的数据也不会丢失。

事务的出现使存储引擎对资源消耗变大了，因为支持事务则流程会变复杂。用户可以选择使用事务的存储引擎，也可以选择不使用事务的存储引擎（不支持事务也支持 LOCK TABLES 等操作，一样可以进行并发控制）。

### 隔离级别

#### 可读未提交

大多数情况下，无益处（虽然性能最好）。

#### 可读已提交

一个事务开始时，只能看见已提交的事务所做的修改。
这个级别又叫不可重复读（nonrepetable read）。

#### 可重复读

每个事务从头到尾都能得到 consistency read。但因为不能防止 phantom row 所以不能防止 phantom read。

#### 可串行化

强制事务串行执行，每一行都加了锁（最起码每个 select 隐式地成为 select in share mode）。

### 死锁

InnoDB 可以自动检测死锁，也可以自动处理死锁-将持有最少的 row x lock 的事务进行回滚。

避免死锁的方法是避免数据冲突。

### 事务日志

WAL 就是事务日志，通常是追加写。

写完事务日志以后，buffer pool 里的 dirty pages 会通过 fsync 之类的操作写进磁盘里。

### MySQL 中的事务

支持事务的存储引擎有：

 - InnoDB
 - NDB Cluster
 - XtraDB
 - PBXT
 
#### 自动提交（autocommit）模式

MySQL 默认会设置 autocommit 为 1。autocommit 对 InnoDB 生效，对 MyISAM 不生效（相当于 autocommit 总是为 1）。

大批量操作数据的命令（如 ALTER 类的 DDL 语句），会强制操作对事务的修改提交。

#### 在事务中混合使用存储引擎

**同一个事务可以跨表操作。**

表可以由不同的存储引擎存储。

**混合使用事务性和非事务性的存储引擎会导致事务无法回滚。**

所以表要显式地指定存储引擎。

#### 隐式锁定和显式锁定

insert、delete、update 会隐式地锁定表里的记录。但 MySQL 支持如下的显式锁：

 - select ... lock in share mode（非 SQL 标准）
 - select ... for update（非 SQL 标准）
 - LOCK TABLES（server 层）
 - UNLOCK TABLES（server 层）

## （InnoDB 中的）MVCC 

包括 MySQL、PostgreSQL、Oracle 都实现了 MVCC，但各自的实现机制不一样，因为 MVCC 没有统一的标准（没有人能说其他实现是错的）。

可以认为 MVCC 是行级锁的一个变种，但大多数情况下 MVCC 代表着无锁操作。

MVCC 为每行保存了两个隐藏列，一行保存行的创建时间（创建事务版本），一行保存行的删除时间（删除事务版本）。这里说的时间，实际上指的是系统版本号（system number version）。每个事务开始的时候，会取当前事务的版本号，作为事务自己的版本。

### SELECT

 - InnoDB 只查找版本早于当前版本的数据行（行的系统版本号小于或等于事务的系统版本号），这样读到的数据，要么在数据开始以前就已经存在，要么是本事务创造的（如果这是一个长事务，则之前已经 insert 过很多带有本 transaction version 的行了）。
 - 行的删除版本未定义，或者大于当前版本号，这样可以保证事务读到的行，在事务开始以前未被删除

### Insert

为每插入的每一行保存当前系统版本号作为行含本号。

### DELETE

InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。

### UPDATE

插入新的一行，保存当前系统版本作为行版本号。保存当前系统版本号到原来的行作为删除标识。

大多数操作都可以不用加锁，只能读取到符合标准的行。RU 总是读取到最新行，Serialize 总是对每个读取的行加锁。

## MySQL 的存储引擎

在文件系统中，MySQL 将每个数据库（也可以称之为 schema）保存为数据目录下的一个子目录。创建表时，MySQL 会在数据库子目录下创建一个表同名的.frm 文件，保存表的定义。

存储引擎使用操作系统中的目录和文件保存了库和表的定义。在 windows 操作系统中，定义是大小写不敏感的；在 unix 操作系统中，大小写是敏感的。

### InnoDB 存储引擎

InnoDB 是默认的事务型存储引擎（transactional storage engine），也是最重要、使用最广泛的存储引擎。它被设计成用来处理大量的 short-lived 事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB 也适用于非事务性存储。

#### InnoDB 的历史

InnoDB 有着复杂的发展历史，最初有旧的 innodb 存储引擎，但最终 Oracle 旗下的 InnoDB 公司提供的 InnoDB plugin 在当前版本原生编译时就成为当代的 InnoDB 引擎。近期的版本主要改进集中在可测量性、可扩展性、可配置化、性能、各种新特性和对 Windows 的支持上。

#### InnoDB 概览

InnoDB 的数据存放在表空间（table space）中，表空间是由 InnoDb 管理的一个黑盒子，由一系列数据文件组成。InnoDB 将表的数据和索引存放在单独的文件中（合一）。

InnoDB 的表基于聚簇索引建立（EveryThing is an Index in InnoDB），因此 InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能。不过它的二级索引中必须包含主键列，所以主键列很大的话，其他的所有索引都会很大。因此，表上的索引较多的话，主键应该尽可能小。

### MyISAM 存储引擎

MyISAM 无事务，崩溃后无法恢复。因为它无事务的特性，所以很多人都一直认为 MySQL 无事务。在无事务的时代，用户依然可以使用 LOCK TABLES 和 UNLOCK TABLES 来进行并发控制。

#### 存储

**MyISAM 将索引和数据文件分开存储**。MyISAM 中的表可以分为 dynamic row 和 fixed row。

#### MyISAM 特性

靠加锁来支持并发。

需要修复表（不是什么好特性）。

（即使对 BLOB 和 TEXT）支持全文索引 + 复杂查询。

Delayed Key Write，对索引的更新是延迟的，所以一旦发生 crash，数据会丢失，又需要修复表（所以不是什么好特性）。

MyISAM 支持对行级进行压缩的压缩表。压缩表可以极大地提高性能，但数据出问题还是要修复。

MyISAM 最典型的性能问题是表锁的问题。

### 其他存储引擎

 - Archive
 - Blackhoe
 - Csv
 - Federated
 - Memory
 - Merge
 - NDB 它让 MySQL 引入了 share nothing 的架构

### 第三方存储引擎

#### OLTP 类存储引擎

Percona 的 XTRDB 是基于 InnoDB 的一个改进版本。XtraDB 可以作为InnoDB 的一个完全的替代产品。

PBXT 支持引擎级别的复制，外键约束，对 SSD 的支持较好，被 MariaDB 所包含。

TokuDB 使用一种新的叫作分行书（Fractal Trees）的索引数据结构。TokuDB 是缓存无关的，因此即使其大小超过内存性能也不会下降，也就没有内存生命周期和碎片的问题。TokuDB 是种大数据存储引擎，因为其拥有很高的压缩比，可以在很大的数据量上创建大量索引。

RethinkDB 最初是为 SSD 设计的，和 PBXT 差不多。

### 选择合适的存储引擎

除非必须使用 InnoDB 不具备的特性而不能妥协，否则应该使用 InnoDB。

实际上，OLTP 的场景下使用 InnoDB，OLAP 场景，使用大数据框架来分析，已经成为了大多数互联网公司的标配场景。

不要轻易认定“MyISAM 比 InnoDB”之类的经验之谈。在很多已知场景下，InnoDB 的速度是 MyISAM 望尘莫及的，特别是能够使用聚簇索引查询，或者所访问的数据都可以放入内存中的应用。

### 转换表的存储引擎

#### ALTER TABLE

```SQL
ALTER TABLE mytable ENGINE = InnoDB;
```

这个操作会执行很长时间，MySQL 会把原表复制到新表中（这种新表被重新组织过，可以消除空洞）。在复制的过程中会消耗系统所有的 I/O 能力，而且表上会加读锁（**变成了 READ ONLY 的表，算是一种半停机的设置**）。

如果转换表的存储引擎，将会失去和原引擎相关的所有特性。一张表切换两次不同的引擎，可能导致外键都丢失。

#### EXPORT 和 IMPORT

可以使用 mysqldump 把表导出，然后修改 CREATE TABLE 的 engine 选项，注意同时修改表名，因为同一个 db 里不能存在相同的表名。

#### CREATE 和 SELECT

```SQL
CREATE TABLE innodb_table LIKE myisam_table;
ALTER TABLE innodb_table ENGINE=innodb;
INSERT INTO innodb_table SELECT * FROM myisam_table;
```

如果数据量不大的话，这样做很好；否则需要考虑分批处理，因为这样会产生过多的 undo。

可以考虑使用 Percona Toolkit 提供的 pt-online-schema-change 的工具。

## MySQL Timeline

5.5 版本的 MySQL 是史上质量最高的版本。体现了 Oracle 收购了 MySQL AB 以后对产品的关注。

## 总结

虽然有很多不同的插件 API，但存储引擎 API 还是最重要的。如果能理解 MySQL 在存储引擎和服务层之间处理查询时如何通过 API 来回交互，就能抓住 MySQL 基础架构的精髓。

**对 InnoDB 而言，一切操作都是事务。**

Oracle 一开始收购了 InnoDB，而后收购了 MySQL，最终导致了两者的融合。

# MySQl 基准测试

基准测试（benchmark）是 MySQL 新手和专家都需要掌握的一项基本技能。简单地说，基准测试是针对系统设计的一种压力测试。本章讲讨论基准测试的重要性、策略和工具。我们将特别讨论一下 sysbench，这是一款非常优秀的 MySQL 基准测试工具。

## 为什么要做基准测试

基准测试是唯一有效的、可以学习系统在给定的工作负载下会发生什么的方法。
