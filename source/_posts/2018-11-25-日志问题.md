---
title: 日志问题
date: 2018-11-25 16:04:21
tags:
- SLF4j
- Logback
- Log4j
---
# Logger、Appender

对于常见的 log4j.xml/slf4j.xml 而言：

Logger：日志记录器，负责收集处理日志记录（如何处理日志）

Appender：日志输出目的地，负责日志的输出（输出到什么地方）

Layout：日志格式化，负责对输出的日志格式化（以什么形式展现）

一个 logger 可以对应多个 appender，一个 appender 只能对应一个 layout。

rootlogger 总是 DEBUG 的 LEVEL。

默认其他 logger 都是从 root logger 里面派生出来的，主要继承了全局的 log level（`<root level="warn">`会直接导致全局的 log level 提升到 warn），而它的additivity 的配置可以禁掉日志在不同的 appender 里面的重复输出。一套 logger 的例子是：

```xml
<loggers>
        <!--单独配置 logger，如果一个类的包路径很特别，需要单独定制 logger 的配置，可以这样做，配置单独的 level -->
        <logger name="com.some_company" level="info"/>
        <logger name="org.springframework" level="info"/>
        
        <!-- 只规定了全局的 log level，所有没有被单独配置的 logger 都会受这个 logger 的影响 -->
        <root level="info">
            <appender-ref ref="requestLog"/>
            <appender-ref ref="warnLog"/>
            <appender-ref ref="errorLog"/>
            <appender-ref ref="customAppender1"/>
            <appender-ref ref="customAppender2"/>
        </root>
    </loggers>
```


假设定义一个 APPENDER 是这样的。它与某个 log file 就联系起来了。

```xml
    <appender name="A-APPENDER"
              class="class">
        <param name="file" value="${loggingRoot}/${sys_host_name}/common-default.log"/>
        <param name="append" value="true"/>
        <param name="encoding" value="GBK"/>
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="%d [%X{loginUserEmail}/%X{loginUserID}/%X{remoteAddr}/%X{clientId} - %X{requestURIWithQueryString}] %-5p %c{2} - %m%n"/>
        </layout>
    </appender>
```

然后可以定义一个 logger：

```xml
<!-- 用appender 的名字或者日志文件名来命名 logger -->
<logger name="LOGGING_FILE_NAME" additivity="false">
    <level value="INFO"/>
    <appender-ref ref="A-APPENDER"/>
    <appender-ref ref="B-APPENDER" />
</logger>
```

然后可以用名字来引用 logger：

```java
    private static final Logger LOGGING_FILE_NAME_LOGGER = LoggerFactory.getLogger(LOGGING_FILE_NAME);
```

我们也可以定义一个到达某个包名的 logger：

```xml
    <!-- 用包名来命名 logger，本包内的 class 自动获得这个 logger -->
    <logger name="com.a.b" additivity="false">
        <!-- 可以覆盖继承下来的 level -->
        <level value="${abc_loggingLevel}"/>
        <appender-ref ref="A-APPENDER"/>
        <appender-ref ref="B-APPENDER" />
    </logger>
```

然后可以用类名来引用 logger：

```java
    private static final Logger logger = LoggerFactory.getLogger(A.class);
```

一个典型的 log4j2.xml：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn" name="MyApp" packages="">
  <Appenders>
    <!-- 可以直接用 type 来决定特殊的 console -->
    <Console name="STDOUT" target="SYSTEM_OUT">
      <PatternLayout pattern="%m%n"/>
    </Console>
     <File name="MyFile" fileName="logs/app.log">
      <PatternLayout>
        <Pattern>%d %p %c{1.} [%t] %m%n</Pattern>
      </PatternLayout>
    </File>
  </Appenders>
  <Loggers>
    <Root level="error">
      <AppenderRef ref="STDOUT"/>
    </Root>
  </Loggers>
</Configuration>
```

一个典型的logback.xml：

```xml
<appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!-- 注意这个 target -->
        <target>System.out</target>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} %msg%n</pattern>
        </encoder>
    </appender>
 
    <root level="error">
        <appender-ref ref="console"/>
    </root>


<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="true">
    <!-- 应用名称 -->
    <property name="APP_NAME" value="logtest" />
    <!--日志文件的保存路径,首先查找系统属性-Dlog.dir,如果存在就使用其；否则，在当前目录下创建名为logs目录做日志存放的目录 -->
    <property name="LOG_HOME" value="${log.dir:-logs}/${APP_NAME}" />
    <!-- 日志输出格式 -->
    <property name="ENCODER_PATTERN"
        value="%d{yyyy-MM-dd  HH:mm:ss.SSS} [%thread] %-5level %logger{80} - %msg%n" />
    <contextName>${APP_NAME}</contextName>
 
    <!-- 控制台日志：输出全部日志到控制台 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <Pattern>${ENCODER_PATTERN}</Pattern>
        </encoder>
    </appender>
 
    <!-- 文件日志：输出全部日志到文件 -->
    <appender name="FILE"
        class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/output.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${ENCODER_PATTERN}</pattern>
        </encoder>
    </appender>
 
    <!-- 错误日志：用于将错误日志输出到独立文件 -->
    <appender name="ERROR_FILE"
        class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/error.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${ENCODER_PATTERN}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>WARN</level>
        </filter>
    </appender>
    
    <!-- 独立输出的同步日志 -->
    <appender name="SYNC_FILE"  class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/sync.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${ENCODER_PATTERN}</pattern>
        </encoder>
    </appender>
    
    <logger name="log.sync" level="DEBUG" addtivity="true">
        <appender-ref ref="SYNC_FILE" />
    </logger>
    
    <root>
        <level value="DEBUG" />
        <appender-ref ref="STDOUT" />
        <appender-ref ref="FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>
```

# ConversionPattern

<param name="ConversionPattern" value="%d %m%n"/>
这里的 % 不是类型前缀，而是上下文变量前缀。
%d 意味着当前时间
%m 意味着日志内容
%n 意味着换行符

# 配置文件的内容格式

log4j.appender.appenderName=
> appenderName org.apache.log4j.ConsoleAppender（控制台）
> org.apache.log4j.FileAppender（文件）
> org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
> org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
> org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）


log4j.appender.appenderName.layout = ??

> org.apache.log4j.HTMLLayout（以HTML表格形式布局）
> org.apache.log4j.PatternLayout（可以灵活地指定布局模式）
> org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）
> org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）

ConsoleAppender选项

> Threshold=DEBUG:指定日志消息的输出最低层次。
> ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
> Target=System.err:默认情况下是System.out,指定输出控制台

FileAppender 选项

> Threshold=DEBUG:指定日志消息的输出最低层次。
> ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
> File=mylog.txt:指定消息输出到mylog.txt文件。
> Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。

RollingFileAppender 选项

> Threshold=DEBUG:指定日志消息的输出最低层次。
> ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
> File=mylog.txt:指定消息输出到mylog.txt文件。
> Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。
> MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB.
> 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。
> MaxBackupIndex=2:指定可以产生的滚动文件的最大数。

日志信息格式中几个符号所代表的含义

> -X号: X信息输出时左对齐； 
> %p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL, 
> %c: 输出日志信息所属的类目，通常就是所在类的全名 %t: 输出产生该日志事件的线程名
> %x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java
> servlets这样的多客户多线程的应用中。 %%: 输出一个”%”字符 
> %F: 输出日志消息产生时所在的文件名称 
> %L: 输出代码中的行号
> %m   输出代码中指定的消息%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL
> %r   输出自应用启动到输出该log信息耗费的毫秒数
> %t   输出产生该日志事件的线程名 
> %n   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” 
> %d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日  22 ： 10 ： 28 ， 921 
> %l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：test.main(test.java: 10 )

# Level

## SLF4J

level 越高，能越把低 level 的日志打出来。

```java
/**
     * No events will be logged.
     */
    OFF(0),

    /**
     * A severe error that will prevent the application from continuing.
     */
    FATAL(100),

    /**
     * An error in the application, possibly recoverable.
     */
    ERROR(200),

    /**
     * An event that might possible lead to an error.
     */
    WARN(300),

    /**
     * An event for informational purposes.
     */
    INFO(400),

    /**
     * A general debugging event.
     */
    DEBUG(500),

    /**
     * A fine-grained debug message, typically capturing the flow through the application.
     */
    TRACE(600),

    /**
     * All events should be logged.
     */
    ALL(Integer.MAX_VALUE);
```

## Log4j

```java
/**
     * No events will be logged.
     */
    OFF(0),

    /**
     * A severe error that will prevent the application from continuing.
     */
    FATAL(100),

    /**
     * An error in the application, possibly recoverable.
     */
    ERROR(200),

    /**
     * An event that might possible lead to an error.
     */
    WARN(300),

    /**
     * An event for informational purposes.
     */
    INFO(400),

    /**
     * A general debugging event.
     */
    DEBUG(500),

    /**
     * A fine-grained debug message, typically capturing the flow through the application.
     */
    TRACE(600),

    /**
     * All events should be logged.
     */
    ALL(Integer.MAX_VALUE);
```

http://www.cnblogs.com/Fskjb/archive/2011/01/29/1947592.html
https://blog.csdn.net/qq_35246620/article/details/53790350
https://blog.csdn.net/liuxiao723846/article/details/52126936