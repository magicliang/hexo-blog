---
title: 现代垃圾收集器
date: 2020-09-27 16:12:22
tags:
- Java
- JVM
---
所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优：

- 减少临时对象，尽量复用内存
- 使用对象池
- 主动提前释放对象
- 主动 gc

其他情况，可以通过 tuning garbage collector 来解决。

# CMS

CMS 的垃圾收集器默认在新生代就使用 ParNew，ParNew 天然是个 STW 收集器。

ParNew 使用标记-复制算法。标记-复制算法可以分为三个阶段：

- 标记阶段，即从GC Roots集合开始，标记活跃对象；
- 转移阶段，即把活跃对象复制到新的内存地址上；
- 重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。

CMS 是个并发收集器。其操作步骤包括：

 - 初始标记
 - 并发标记
 - 再标记
 - 并发收集

[CMS 将在 Java 14 中被 removed 掉][1]。
 
# G1

老的垃圾收集器总是面临几个问题：

- 所有针对老年代的操作必须扫描整个老年代空间；
- 年轻地和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。

G1是一种服务端应用使用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间（因为它引入了更好的停顿预测模型），同时还能保持较高的吞吐量。

G1的缺点是：停顿预测模型还不够智能；即使使用了 pre-write barrier 和 post-write barrier 并发标记的准确度不够高，所以需要重标记，甚至依然有 concurrent mode 失败的场景。

![g1-regions.jpg](g1-regions.jpg)



参考：

 1. [《G1从入门到放弃》][2]
 2. [《可能是最全面的G1学习笔记》][3]
 3. g1 的 gc 日志可以看[《Understanding G1 GC Logs》][4]。
 4. [《Java Hotspot G1 GC的一些关键技术》][5]

# ZGC


  [1]: https://openjdk.java.net/jeps/363
  [2]: https://zhuanlan.zhihu.com/p/161427950
  [3]: https://zhuanlan.zhihu.com/p/54048685
  [4]: https://blogs.oracle.com/poonam/understanding-g1-gc-logs
  [5]: https://tech.meituan.com/2016/09/23/g1.html
