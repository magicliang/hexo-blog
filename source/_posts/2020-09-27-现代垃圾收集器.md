---
title: 现代垃圾收集器
date: 2020-09-27 16:12:22
tags:
- Java
- JVM
---
所有的垃圾收集器，都基于[弱分代假设][1]。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优：

- 减少临时对象，尽量复用内存
- 使用对象池
- 主动提前释放对象
- 主动 gc

其他情况，可以通过 tuning garbage collector 来解决。

# CMS

CMS 的垃圾收集器默认在新生代就使用 ParNew，ParNew 天然是个 STW 收集器。

ParNew 使用标记-复制算法。标记-复制算法可以分为三个阶段：

- 标记阶段，即从GC Roots集合开始，标记活跃对象；
- 转移阶段，即把活跃对象复制到新的内存地址上；
- 重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。

CMS 是个并发收集器。其操作步骤包括：

 - 初始标记
 - 并发标记
 - 再标记
 - 并发收集

[CMS 将在 Java 14 中被 removed 掉][2]。
 
# G1

老的垃圾收集器总是面临几个问题：

- 所有针对老年代的操作必须扫描整个老年代空间；
- 年轻地和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。

G1是一种服务端应用使用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间（因为它引入了更好的停顿预测模型），同时还能保持较高的吞吐量。

G1的缺点是：停顿预测模型还不够智能；即使使用了 pre-write barrier 和 post-write barrier 并发标记的准确度不够高，所以需要重标记，甚至依然有 concurrent mode 失败的场景。

![g1-regions.jpg](g1-regions.jpg)

关于 gc 日志可以参考[《Understanding G1 GC Log Format》][3]。

minor gc 的日志参考：

![g1-younggc-log.png](g1-younggc-log.png)

从这个图我们也可以看出，如果让 g1 自己选择 region 里面新老分布的比例的话，young 会多小（在一个 4g 的堆上，可能只有 200m 的年轻代）。如果 gc 时间不到 10ms，real 都显示不出来。

global concurrent marking 的日志参考：

![global-concurrent-marking.png](global-concurrent-marking.png)

现实中的 Concurrent Cycles 往往会执行一轮又一轮，直到内存空间的比例降到足够低的水位为止。

搜索 GC pause 可以看到各种各样的 gc 停顿。要找混合垃圾回收直接搜“mixed GCs”或者“(G1 Evacuation Pause) (mixed)”。

一般的 gc 日志的顺序是“[GC pause (G1 Evacuation Pause) (young)” -> “concurrent-root-region-scan-start” -> “Concurrent Cycles” -> “ [GC pause (G1 Evacuation Pause) (young)” -> “[G1Ergonomics (Mixed GCs) start mixed GCs” ->“(G1 Evacuation Pause) (mixed)”（这一步会循环执行）。

每次 gc 开始时，Heap before GC invocations=15872 (full 0)，其中invocations=15872是自JVM启动以来，执行GC的次数。每一次 initial-mark，这个值就会加 1。

常用的 jvm 配置：
```bash
CommandLine flags: -XX:+AlwaysPreTouch -XX:CICompilerCount=4 -XX:ErrorFile=/var/company/logs/com.company.application/vmerr.log.20200928 -XX:G1HeapRegionSize=4194304 -XX:GCLogFileSize=10485760 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDum      pPath=/var/company/logs/com.company.application/heaperr.log.20200928 -XX:InitialHeapSize=4294967296 -XX:Init      iatingHeapOccupancyPercent=40 -XX:MaxGCPauseMillis=100 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=536870912 -XX:MetaspaceS      ize=536870912 -XX:NumberOfGCLogFiles=10 -XX:+PrintAdaptiveSizePolicy -XX:+PrintFlagsFinal -XX:+PrintGC -XX:+PrintGCApplicationS      toppedTime -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintStringTableStatistics       -XX:+PrintTenuringDistribution -XX:ThreadStackSize=512 -XX:+TieredCompilation -XX:-UseBiasedLocking -XX:+UseCompressedClassPoi      nters -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseGCLogFileRotation
```

参考：

 1. [《G1从入门到放弃》][4]
 2. [《可能是最全面的G1学习笔记》][5]
 3. g1 的 gc 日志可以看[《Understanding G1 GC Logs》][6]。
 4. [《Java Hotspot G1 GC的一些关键技术》][7]

# ZGC

> ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：
> 
> - 停顿时间不超过10ms；
> - 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
> - 支持8MB~4TB级别的堆（未来支持16TB）。
> 
> 与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。

![zgc 过程.png](zgc 过程.png)

> ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC
> Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC
> Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。
> 
> ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。

参考：

 1. [《新一代垃圾回收器ZGC的探索与实践》][8]


  [1]: https://www.ps.uni-saarland.de/courses/gc-ws01/slides/generational_gc.pdf
  [2]: https://openjdk.java.net/jeps/363
  [3]: https://dzone.com/articles/understanding-g1-gc-log-format
  [4]: https://zhuanlan.zhihu.com/p/161427950
  [5]: https://zhuanlan.zhihu.com/p/54048685
  [6]: https://blogs.oracle.com/poonam/understanding-g1-gc-logs
  [7]: https://tech.meituan.com/2016/09/23/g1.html
  [8]: https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html
