---
title: 现代垃圾收集器
date: 2020-09-27 16:12:22
tags:
- Java
- JVM
---
所有的垃圾收集器，都基于[弱分代假设][1]。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优：

- 减少临时对象，尽量复用内存
- 使用对象池
- 主动提前释放对象
- 主动 gc

其他情况，可以通过 tuning garbage collector 来解决。

# CMS

CMS 的垃圾收集器默认在新生代就使用 ParNew，ParNew 天然是个 STW 收集器。

ParNew 使用标记-复制算法。标记-复制算法可以分为三个阶段：

- 标记阶段，即从GC Roots集合开始，标记活跃对象；
- 转移阶段，即把活跃对象复制到新的内存地址上；
- 重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。

CMS 是个并发收集器。其操作步骤包括：

 - 初始标记
 - 并发标记
 - 再标记
 - 并发收集

[CMS 将在 Java 14 中被 removed 掉][2]。
 
# G1

老的垃圾收集器总是面临几个问题：

- 所有针对老年代的操作必须扫描整个老年代空间；
- 年轻地和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。

G1是一种服务端应用使用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间（因为它引入了更好的停顿预测模型），同时还能保持较高的吞吐量。

G1的缺点是：停顿预测模型还不够智能；即使使用了 pre-write barrier 和 post-write barrier 并发标记的准确度不够高，所以需要重标记，甚至依然有 concurrent mode 失败的场景。

![g1-regions.jpg](g1-regions.jpg)

关于 gc 日志可以参考[《Understanding G1 GC Log Format》][3]。

minor gc 的日志参考：

![g1-younggc-log.png](g1-younggc-log.png)

从这个图我们也可以看出，如果让 g1 自己选择 region 里面新老分布的比例的话，young 会多小（在一个 4g 的堆上，可能只有 200m 的年轻代）。如果 gc 时间不到 10ms，real 都显示不出来。

global concurrent marking 的日志参考：

![global-concurrent-marking.png](global-concurrent-marking.png)

现实中的 Concurrent Cycles 往往会执行一轮又一轮，直到内存空间的比例降到足够低的水位为止。

搜索 GC pause 可以看到各种各样的 gc 停顿。要找混合垃圾回收直接搜“mixed GCs”或者“(G1 Evacuation Pause) (mixed)”。

一般的 gc 日志的顺序是“[GC pause (G1 Evacuation Pause) (young)” -> “concurrent-root-region-scan-start” -> “Concurrent Cycles” -> “ [GC pause (G1 Evacuation Pause) (young)” -> “[G1Ergonomics (Mixed GCs) start mixed GCs” ->“(G1 Evacuation Pause) (mixed)”（这一步会循环执行）。

每次 gc 开始时，Heap before GC invocations=15872 (full 0)，其中invocations=15872是自JVM启动以来，执行GC的次数。每一次 initial-mark，这个值就会加 1。

常用的 jvm 配置：
```bash
CommandLine flags: -XX:+AlwaysPreTouch -XX:CICompilerCount=4 -XX:ErrorFile=/var/company/logs/com.company.application/vmerr.log.20200928 -XX:G1HeapRegionSize=4194304 -XX:GCLogFileSize=10485760 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDum      pPath=/var/company/logs/com.company.application/heaperr.log.20200928 -XX:InitialHeapSize=4294967296 -XX:Init      iatingHeapOccupancyPercent=40 -XX:MaxGCPauseMillis=100 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=536870912 -XX:MetaspaceS      ize=536870912 -XX:NumberOfGCLogFiles=10 -XX:+PrintAdaptiveSizePolicy -XX:+PrintFlagsFinal -XX:+PrintGC -XX:+PrintGCApplicationS      toppedTime -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintStringTableStatistics       -XX:+PrintTenuringDistribution -XX:ThreadStackSize=512 -XX:+TieredCompilation -XX:-UseBiasedLocking -XX:+UseCompressedClassPoi      nters -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseGCLogFileRotation
```

参考：

 1. [《G1从入门到放弃》][4]
 2. [《可能是最全面的G1学习笔记》][5]
 3. g1 的 gc 日志可以看[《Understanding G1 GC Logs》][6]。
 4. [《Java Hotspot G1 GC的一些关键技术》][7]

# ZGC


  [1]: https://www.ps.uni-saarland.de/courses/gc-ws01/slides/generational_gc.pdf
  [2]: https://openjdk.java.net/jeps/363
  [3]: https://dzone.com/articles/understanding-g1-gc-log-format
  [4]: https://zhuanlan.zhihu.com/p/161427950
  [5]: https://zhuanlan.zhihu.com/p/54048685
  [6]: https://blogs.oracle.com/poonam/understanding-g1-gc-logs
  [7]: https://tech.meituan.com/2016/09/23/g1.html
