---
title: Redis 笔记之四：常用命令
date: 2019-07-22 23:29:49
tags:
- Redis
---
# 1 全局命令

## 1.1 查看所有键
``` bash
# 查看所有键
keys *
```

这个命令会不加区别地，**做全局的键扫描，返回且只返回键。**它的时间复杂度是O（N），线上环境因为无法预测键的数量，应该禁用这个命令。

*看起来 redis 并没有做一个全局的 keys 的缓存，所以并没有办法优化局部性能，但即使存在一个全局的 keys 列表，对这个列表进行遍历，其时间复杂度依然是 O(N)。*

## 1.2 键总数

```bash
# 查看所有键
dbsize
```

这个操作的性能是 O(1)，也就意味着可以直接被线上使用。

*它可以作为查询全部数据以前的预优化，至少全局的记录数量可以预先提取出来，以获得分页查询的依据*。

## 1.3 检查键是否存在

```bash
# 确认 java 作为一个键是否存在
exists java
```

如果存在返回 1，不存在返回 0。

注1：在存在多个候选返回值的时候，redis会返回语义更加丰富的返回值。如返回成功或失败，可以直接返回true或false，但返回0既可以表示失败，也可以表示操作的操作数（operand）为0，而返回非0不仅可以告诉我们操作成功了，而且还会精确地告诉我们操作了多少个对象，可谓一举两得。这种设计思路遍布 Redis API 中。

问题：估计有个全局优化，能够不返回具体值的情况下得到是否存在某个 key 的结论。

## 1.4 删除键

```bash
# 删除 java 键
del java
```

如果删除成功则返回 1，否则返回 0

## 1.5 键过期

```bash
set hello world

set hello world EX 10 NX

# 在 redis 中，最早支持的时间单位为second，如果不特别指定单位，指定时间时数字都代表秒。这个策略可以推广到其他系统里。美团的 squirrel 系统里面的默认时间单位就是秒。
expire hello 10
```

set 是为比较少的返回“OK”的 command。

因为这个命令有复合的EX、PX、NX、XX等选项，所以其他相对的命令（如SETNX）可能会被设为过期，且被移除。

expire 命令的结果也是 0 和 1。

如果使用了 expire 命令，还有一个可以拿来轮询的 ttl 命令，可以告诉我们键的剩余时间：

```bash
ttl hello
(integer) 7

......
# 如果返回-2，意味着键已被删除
ttl hello
(integer) -2

# 这时候试着取健值，则得到 nil

get hello
(nil) 
```

## 1.6 键的数据结构类型

```bash
set a b
type a 
string

# rpush 会强制转化一个 key 到 list 类型
rpush mylist a b c
# 返回结果为 7
(integer) 7
type mylist
list

# 不存在的键
type non_exist_key
# 返回 none
```

# 2 字符串命令

## 2.1 设/取值

```bash
set hello world
exsts hello
setnx hello wolrd
## 若存在才设值
set hello jedix xx

get hello
```

## 2.2 批量设/取值

```bash
mset a 1 b 2 c 3
get a
get b
get c

# 取不到返回nil
mget a b c d
```

如果使用平凡的取/设值命令，时间开销为：

总开销= n * (一次网络开销 + 一次操作开销)

如果使用批量取/设值命令，时间开销为：

总开销= 一次网络开销 + n * (一次操作开销)

redis每秒可以处理上万的读写操作，相当于每次读写操作的开销小于0.1毫秒，而网络开销很难低于1毫秒。根据阿姆达尔定律，网络开销的减少才是性能优化的大头。

## 2.2 加/减值

因为 Redis 本身是单线程架构，所以本身不需要其他设计中的悲观锁或者 cas 操作保证操作正确性。
返回的自增结果永远是正确的。

```bash
# 值不是整数，返回错误
# 值是整数，返回自增后的结果
# 值不存在，按照结果为0自增，返回结果1
incr java

decr java

incrby java 10
decrby java 5
# 没有 decrbyfloat 命令
incrbyfloat java 4.3
```
**注意，java里涉及数字的缺省值都是0，而且只是缺省值，并不是终值。**

## 2.3 位操作命令

背景见：https://redis.io/topics/data-types-intro#bitmaps

Redis 并不只是一个平凡的 kv 数据存储，而是一个拥有许多数据类型的服务器。其中有一种类型是用 String 来解释为位图-“Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type”。字符串是safe blobs，最大长度是 512 MB，恰好等于一个2的32次方的位图。字符串的英文字符，都符合（comply to）ascii编码。

所谓的位图，可以用紧凑的方式来表示一个大的 true/false 值域。

```bash
# 把键的 offset 的位取出来，如果offset无值，则取0
getbit hello 10
# 把键的 offset 的位设值，只能设值0或1，返回旧值
setbit hello 1000 1
# Number of set bits in the range
bitcount hello

# 1st position of 1 or 0 in the key in range. O(N)
BITPOS hello  0

# 与或非
SET key1 "foobar"
SET key2 "abcdef"
BITOP AND dest key1 key2
GET dest
```


## 2.4 其他命令

```bash
# 返回最后结果的长度
append hello 123

# 返回结果的长度
strlen hello

# 原子化地设值并返回旧值
getset hello world123

# 设值指定位置的字符，返回修改后的字符串长度
setrange hello 1 a

# 设定指定位置的值，并返回。start 和 end 都是闭区间
getrange hello 1 2
```



```bash
```