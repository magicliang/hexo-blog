---
title: MySQL 的隔离级别和锁
date: 2020-07-19 16:22:15
tags:
- MySQL
- 数据库
---
# 数据库的隔离级别

数据库的资源必然被并发访问，否则无法满足业务的并发吞吐的要求。但并发访问始终需要避免四类问题：

- 更新丢失：多个事务在不互相感知和协同的时候（主要是同时更新同一行），最后一个更新会把之前所有的事务更新覆盖掉。
- 脏读：事务 a 对数据进行修改，但未提交时，数据**并未进入一致状态**（未提交的事务是不可靠的）；这时候事务 b 来读取未提交的事务的不一致的数据，就会产生业务逻辑问题（实际上分布式事务里一样有这样的问题，只不过很多人意识不到）。
- 不可重复读：一个事务在读取某些数据后的某个时间，再次读取之前读过的数据，却发现其读出的数据已经发生了改变、或者某些记录已经被删除了。这种现象被称为“不可重复读”。
- 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象被称为“幻读”。

隔离级别规定了一个事务中所做的修改在哪些事务内和事务间是可见的。ANSI SQL 92 规定了 4 个隔离级别，MySQL 实现为以下四个级别：

## 可读未提交 Read Uncommitted

不锁定任何数据。

不禁 insert 也不禁 update。

在这种隔离级别里面，会出现脏读和更新丢失，即事务之间相互干扰，事务内部的中间值都可以被读到。

## 可读已提交

锁定要写入的数据。

从侧面来看，既加了锁但没有锁定其他数据，只能是行锁。

禁对正要写的数据的update。

可能出现不可重复读，即正在读而不在写的数据不会被锁，在一个事务内读的数据，可能会被其他事务的终值 update。

## 可重复读

锁定正在读写的数据。从侧面看，是表锁还是行锁？此时依然多个事务还是可以并行化不相互阻塞的。

禁当前读写区域的update。

克服了不可重复读，但会出现幻读。即有些行本身是不被读写的，不能阻止相邻行的插入，也就是说会影响aggregate的结果或者where里的条件判断。

## 序列化

禁掉正在读写的所有相关数据，其实就是锁定表。

禁掉当前表的insert和update。

克服了一切并发事务的污染。


## 默认隔离级别

大部分其他数据库是Read committed，MySQL是 Repeatable Read。

MySQL 是一个更严格的数据库。

JDBC 默认提供第五种隔离级别。

# MySQL 的锁

锁可以用于管理共享资源，RDBMS 能够提供层次化的锁，而普通的文件系统没有这一关键特性（文件系统并不是没有锁，而是没有针对表和记录的锁）。

![MySQL Lock.png](MySQL Lock.png)
[MySQL Lock.xmind](MySQL Lock.xmind)

## Lock 和 Latch

|锁类型|lock|latch|
|:--:|:--:|:--:|
|对象|事务|线程|
|保护|数据库内容|内存数据结构|
|持续时间|整个事务过程|临界资源|
|模式|行锁、表锁、意向锁|读写锁、互斥量|
|死锁|通过 waits-for-graph、timeout 等机制来检测死锁的存在|无死锁检测机制，只有通过加锁顺序（lock-leveling）来避免死锁的出现|
|存在于|在 LockManager 的哈希表中|在每个数据结构的对象中|

## 锁的颗粒度

|锁类型|表|页|行|
|:--:|:--:|:--:|
|InnoDB|支持|不支持|支持|
|MyISAM|支持|不支持|不支持|
|BDB|支持|支持|不支持|

## 意向锁

MySQL 的等值查询和 range 查询，也支持等值更新和 range 更新。这里面隐藏了另一个问题：对表进行修改，就需要加表锁，而加表锁和加行锁实际上是互斥的。能不能加表锁，需要逐一确认每一行的行锁吗？

使用意向锁以后的工作方式是：

 - 对行进行修改的事务需要先对表加意向锁，然后再加行锁。
 - 对表进行修改的事务需要等意向锁释放，然后再加表锁。

意向锁是一张表级锁（[Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table][1]）

## S 锁、X 锁

InnoDB 实现了标准的行级锁（换言之，所有的 ANSI SQL 都应该实现这两种锁），也就是共享锁（Shared Lock）和排他锁（Exclusive Lock）。

共享锁（读锁、S锁），允许事务读一行数据。

排他锁（写锁、X锁），允许事务删除或更新一行数据。

## 锁的兼容性（compatibility）

|锁类型|X|IX|S|IS|
|:--:|:--:|:--:|:--:|:--:|
|X|Conflict|Conflict|Conflict|Conflict|
|IX|Conflict|Compatible|Conflict|Compatible|
|S|Conflict|Conflict|Compatible|Compatible|
|IS|Conflict|Compatible|Compatible|Compatible|

可以看出，x 锁跟所有锁都不兼容。
意向锁和非意向锁之间相互兼容。

# MVCC

MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC 的好处是读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。


  [1]: https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks
