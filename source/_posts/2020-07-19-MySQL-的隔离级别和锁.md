---
title: MySQL 的隔离级别和锁
date: 2020-07-19 16:22:15
tags:
- MySQL
- 数据库
---
# 数据库的隔离级别

数据库的资源必然被并发访问，否则无法满足业务的并发吞吐的要求。但并发访问始终需要避免四类问题：

- 更新丢失：多个事务在不互相感知和协同的时候（主要是同时更新同一行），最后一个更新会把之前所有的事务更新覆盖掉。
- 脏读：事务 a 对数据进行修改，但未提交时，数据**并未进入一致状态**（未提交的事务是不可靠的）；这时候事务 b 来读取未提交的事务的不一致的数据，就会产生业务逻辑问题（实际上分布式事务里一样有这样的问题，只不过很多人意识不到）。
- 不可重复读：一个事务在读取某些数据后的某个时间，再次读取之前读过的数据，却发现其读出的数据已经发生了改变、或者某些记录已经被删除了。这种现象被称为“不可重复读”。
- 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象被称为“幻读”。

隔离级别规定了一个事务中所做的修改在哪些事务内和事务间是可见的。ANSI SQL 92 规定了 4 个隔离级别，MySQL 实现为以下四个级别：

## 可读未提交 Read Uncommitted

不锁定任何数据。

不禁 insert 也不禁 update。

在这种隔离级别里面，会出现脏读和更新丢失，即事务之间相互干扰，事务内部的中间值都可以被读到。

## 可读已提交

锁定要写入的数据。

从侧面来看，既加了锁但没有锁定其他数据，只能是行锁（record-lock）。

禁对正要写的数据的update。

可能出现不可重复读，即正在读而不在写的数据不会被锁，在一个事务内读的数据，可能会被其他事务的终值 update。

## 可重复读

锁定正在读写的数据。此时依然多个事务还是可以并行化不相互阻塞的。

禁当前读写区域的update。

克服了不可重复读，但会出现幻读。即有些行本身是不被读写的，不能阻止相邻行的插入，也就是说会影响aggregate的结果或者where里的条件判断。

InnoDB 在查询和更新的时候，使用 Next-Key-Lock 同时锁定 record + 相关的范围，防止相关查询条件涉及范围内不会插入新的记录被插入，不再出现幻读。

## 序列化

禁掉正在读写的所有相关数据，其实就是锁定表。

禁掉当前表的insert和update。

克服了一切并发事务的污染。

从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)-换言之，即使不显式地更改隔离级别，只要显式地使用 S 锁和 X 锁，都会触发 serial。

Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。


## 默认隔离级别

大部分其他数据库是Read committed，MySQL是 Repeatable Read。

MySQL 是一个更严格的数据库。

JDBC 默认提供第五种隔离级别。

# MySQL 的锁

锁可以用于管理共享资源，RDBMS 能够提供层次化的锁，而普通的文件系统没有这一关键特性（文件系统并不是没有锁，而是没有针对表和记录的锁）。

## Lock 和 Latch

|锁类型|lock|latch|
|:--:|:--:|:--:|
|对象|事务|线程|
|保护|数据库内容|内存数据结构|
|持续时间|整个事务过程|临界资源|
|模式|行锁、表锁、意向锁|读写锁、互斥量|
|死锁|通过 waits-for-graph、timeout 等机制来检测死锁的存在|无死锁检测机制，只有通过加锁顺序（lock-leveling）来避免死锁的出现|
|存在于|在 LockManager 的哈希表中|在每个数据结构的对象中|

## 锁的颗粒度

|锁类型|表|页|行|
|:--:|:--:|:--:|
|InnoDB|支持|不支持|支持|
|MyISAM|支持|不支持|不支持|
|BDB|支持|支持|不支持|

## 意向锁

MySQL 的等值查询和 range 查询，也支持等值更新和 range 更新。这里面隐藏了另一个问题：对表进行修改，就需要加表锁，而加表锁和加行锁实际上是互斥的。能不能加表锁，需要逐一确认每一行的行锁吗？

使用意向锁以后的工作方式是：

 - 对行进行修改的事务需要先对表加意向锁，然后再加行锁。
 - 对表进行修改的事务需要等意向锁释放，然后再加表锁。

意向锁是一张表级锁（[Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table][1]）

## S 锁、X 锁

InnoDB 实现了标准的行级锁（换言之，所有的 ANSI SQL 都应该实现这两种锁），也就是共享锁（Shared Lock）和排他锁（Exclusive Lock）。

共享锁（读锁、S锁），允许事务读一行数据。

排他锁（写锁、X锁），允许事务删除或更新一行数据。

## 锁的兼容性（compatibility）

|锁类型|X|IX|S|IS|
|:--:|:--:|:--:|:--:|:--:|
|X|Conflict|Conflict|Conflict|Conflict|
|IX|Conflict|Compatible|Conflict|Compatible|
|S|Conflict|Conflict|Compatible|Compatible|
|IS|Conflict|Compatible|Compatible|Compatible|

注意，s 和 x 锁都是**行锁**。
可以看出，x 锁跟所有锁都不兼容。
意向锁和非意向锁之间相互兼容。

# MVCC

MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC 的好处是读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。

在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。注意，MVCC 本质上是追求无锁读。因此，即使是加 S 锁的读（select * from table in share mode），也算是一种当前读而不是快照读。

![MVCC.png](MVCC.png)
[MVCC.xmind](MVCC.xmind)

如果同时看 MVCC 和锁，则会得到这幅图：

!(innodb-隔离级别.png)[innodb-隔离级别.png]

# 两阶段锁

传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：Two-Phase Locking。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。

![2PL.jpg](2PL.jpg)

# 锁的实战

## SQL1：select * from t1 where id = 10;

不加锁。因为MySQL是使用多版本并发控制的，读不加锁。

![sql1.jpeg](sql1.jpeg)

## SQL2：delete from t1 where id = 10;

这个问题没有简单答案，真正加锁的顺序，取决于“where 涉及的列 + 隔离级别的组合关系”。

在 RC 的隔离级别之下：
 - 如果 id 是主键，update 不会回表，所以只要在行上加 record-lock 即可。
 - 若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。
 - 若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。
 - 若 id列上没有索引，只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。**如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤**。因此也就把所有的记录，都锁上了。
 
在 RR 的隔离级别之下：
 - id非唯一索引，则同时加上 record-lock + gap-lock。
![RR-update.png](RR-update.png)

GAP锁有何用？

其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。

如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。

如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。

 - id无索引
![rr+非唯一索引.png](rr+非唯一索引.png)

如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？

在这种情况下，这个表上，除了不加锁的快照读，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。

当然，跟组合四：[id无索引, Read Committed]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了 innodb_locks_unsafe_for_binlog 参数。更详细的关于semi-consistent read的介绍，可参考：MySQL+InnoDB semi-consitent read原理及实现分析。
 
结论：

 - 索引越精细加锁越少，索引不精细可能锁表。
 - 在 RR 的级别下，如果涉及非唯一的索引（不管是不是主键），都会防止幻读而插入 Next-Key—Lock
 - 在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。
 - 索引上 GAP lock 的实际 x-lock 锁定范围，是索引里面命中的 index filter 的 range。
 - 而记录上 record-lock 的锁定范围，则由回表以后定位到的 record 确定。

## SQL3

![SQL3.png](SQL3.png)
![SQL-3-加锁情况.png](SQL-3-加锁情况.png)

从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持Index Condition Pushdown(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上读取数据后到引擎层进行过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。

结论：在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key 确定的范围，需要加上 GAP 锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足 Index Filter 的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。

# 死锁

![死锁1.png](死锁1.png)

注意回顾两阶段加锁的原理，可以看到逆序加锁就会发生死锁。

![死锁2.png](死锁2.png)

第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。即索引的锁交叉了，但聚簇索引（记录）上的锁却冲突了。

结论：死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。

# 锁状态

了解了死锁产生的原因，如何知道数据库当前锁的状态呢？如何查看死锁情况呢？

目前在MySQL中锁相关的视图如下：

information_schema.innodb_trx ：记录事务相关的信息，包括事务开始时间、事务SQL、事务权重（死锁发生时，回滚事务参考的权值）等

information_schema.innodb_locks：记录事务持有锁的信息，包括事务持有的锁类型、被锁的表等

infomation_schema.innodb_lock_waits：记录事务等待情况，每个事务被哪些事务所阻塞

死锁情况可通过[show engine innodb status查看][2]。


  [1]: https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks
  [2]: https://blog.csdn.net/dhfzhishi/article/details/81272360
